---
layout: post
title: Git教程(二)
date: 2017-7-12
tags: [教程, 总结, 备忘]
---

> BY 童仲毅([geeeeeeeeek@github](https://github.com/geeeeeeeeek/git-recipes/))
>
> 这是一篇在[原文(BY atlassian)](https://www.atlassian.com/git/tutorials/setting-up-a-repository)基础上演绎的译文。除非另行注明，页面上所有内容采用知识共享

---

## 图解 Git 命令

此页图解git中的最常用命令。如果你稍微理解git的工作原理，这篇文章能够让你理解的更透彻。

## 基本用法

![enter image description here](https://camo.githubusercontent.com/4a19fb7e615ece473d64bc8f9b33a40c56e85f6a/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f62617369632d75736167652e737667)
上面的四条命令在工作目录、stage缓存(也叫做索引)和commit历史之间复制文件。

 *   `git add files` 把工作目录中的文件加入stage缓存
 *   `git commit` 把stage缓存生成一次commit，并加入commit历史
 *   `git reset -- files` 撤销最后一次`git add files`，你也可以用`git reset` 撤销所有stage缓存文件
 *   `git checkout -- files` 把文件从stage缓存复制到工作目录，用来丢弃本地修改

你可以用 `git reset -p`、`git checkout -p` 或 `git add -p`进入交互模式，也可以跳过stage缓存直接从commit历史取出文件或者直接提交代码。

![enter image description here](https://camo.githubusercontent.com/469ae8bbb267eccde8025f88c7b481a5c653cd54/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f62617369632d75736167652d322e737667)

  *   `git commit -a ` 相当于运行`git add`把所有当前目录下的文件加入stage缓存再运行`git commit`。
  *   `git commit files` 进行一次包含最后一次提交加上工作目录中文件快照的提交，并且文件被添加到stage缓存。
  *   `git checkout HEAD -- files` 回滚到复制最后一次提交。

## 约定

后文中以下面的形式使用图片：
![enter image description here](https://camo.githubusercontent.com/769125a4109e268d5681b114e64c65b0ce637177/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636f6e76656e74696f6e732e737667)
绿色的5位字符表示提交的ID，分别指向父节点。分支用橙色显示，分别指向特定的提交。当前分支由附在其上的_HEAD_标识。

这张图片里显示最后5次提交，_ed489_是最新提交。 _master_分支指向此次提交，另一个_maint_分支指向祖父提交节点。

## 命令详解

### Diff

有许多种方法查看两次提交之间的变动，下面是其中一些例子。

![enter image description here](https://camo.githubusercontent.com/7d99d5d4be11e270791a9b52bd90427f1f006b72/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f646966662e737667)

### Commit

提交时，git用stage缓存中的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是_master_。

在运行命令之前，_master_指向_ed489_，提交后，_master_指向新的节点_f0cec_并以_ed489_作为父节点。
![enter image description here](https://camo.githubusercontent.com/fcce1a337dcccab3812b1a4fa31f0c9eabb01d38/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636f6d6d69742d6d61737465722e737667)
即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在_master_分支的祖父节点_maint_分支进行一次提交，生成了_1800b_。

这样，_maint_分支就不再是_master_分支的祖父节点。此时，[merge](#merge) 或者 [rebase](#rebase) 是必须的。
![enter image description here](https://camo.githubusercontent.com/80e8f42e55df3235f064f47fc6837ef467985a77/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636f6d6d69742d6d61696e742e737667)
如果想更改一次提交，使用  `git commit --amend`。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。
![enter image description here](https://camo.githubusercontent.com/18a083942ab146236d5487d6afdbd47ff29121e5/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636f6d6d69742d616d656e642e737667)
另一个例子是[分离HEAD提交](#detached)，在后面的章节中介绍。

### Checkout

checkout命令用于从历史提交（或者stage缓存）中拷贝文件到工作目录，也可用于切换分支。

当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到stage缓存和工作目录。比如，`git checkout HEAD~ foo.c`会将提交节点_HEAD~_（即当前提交节点的父节点）中的`foo.c`复制到工作目录并且加到stage缓存中。如果命令中没有指定提交节点，则会从stage缓存中拷贝内容。注意当前分支不会发生变化。
![enter image description here](https://camo.githubusercontent.com/3feaa8deca992e8b38b1b1d49df77008c860ea3e/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636865636b6f75742d66696c65732e737667)
当不指定文件名，而是给出一个（本地）分支时，那么_HEAD_标识会移动到那个分支（也就是说，我们“切换”到那个分支了），然后stage缓存和工作目录中的内容会和_HEAD_对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到stage缓存和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。
![enter image description here](https://camo.githubusercontent.com/27bfb827dfd394da24d5385077a10ec958777ad7/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636865636b6f75742d6272616e63682e737667)
如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像_master~3_类似的东西，就得到一个匿名分支，称作_detached HEAD_（被分离的_HEAD_标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行`git checkout v1.6.6.1`（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说`git checkout master`。然而，当提交操作涉及到“分离的HEAD”时，其行为会略有不同，详情见在[下面](#detached)。
![enter image description here](https://camo.githubusercontent.com/7d04dc9846a4b5ddd0ae07b96ac2c405da907a93/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636865636b6f75742d64657461636865642e737667)

### HEAD标识处于分离状态时的提交操作

当_HEAD_处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。你可以认为这是在更新一个匿名分支。
![enter image description here](https://camo.githubusercontent.com/b26cad5d2da9af51323d120ba6615f0261525243/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636f6d6d69742d64657461636865642e737667)
一旦此后你切换到别的分支，比如说_master_，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用_2eecb_。
![enter image description here](https://camo.githubusercontent.com/589d0adf7d97bd28c1252703567506b40d139c54/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636865636b6f75742d61667465722d64657461636865642e737667)
但是，如果你想保存这个状态，可以用命令`git checkout -b name`来创建一个新的分支。
![enter image description here](https://camo.githubusercontent.com/2b69e1064869feeea4ed1db7a96d95bc98f825a1/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f636865636b6f75742d622d64657461636865642e737667)

### Reset

reset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史commit历史中复制文件到索引，而不动工作目录。

如果不给选项，那么当前分支指向到那个提交。如果用`--hard`选项，那么工作目录也更新，如果用`--soft`选项，那么都不变。
![enter image description here](https://camo.githubusercontent.com/9ae437d1a767cc3df72b2abba3500d62bd32b9e8/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f72657365742d636f6d6d69742e737667)
如果没有给出提交点的版本号，那么默认用_HEAD_。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用`--hard`选项，工作目录也同样。
![enter image description here](https://camo.githubusercontent.com/6ad2f0d73310d226058f2249c3fb83d41004f95f/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f72657365742e737667)
如果给了文件名(或者 `-p`选项), 那么工作效果和带文件名的[checkout](#checkout)差不多，除了索引被更新。
![enter image description here](https://camo.githubusercontent.com/9bbecc79c89ad42a6762ec80ac315fa4d2068a72/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f72657365742d66696c65732e737667)

### Merge

merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。

另一种情况是如果当前提交是另一个分支的祖父节点，就导致_fast-forward_合并。指向只是简单的移动，并生成一个新的提交。
![enter image description here](https://camo.githubusercontent.com/cb2156b6a6f38c643609d576e563fe3ecc5c5a92/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f6d657267652d66662e737667)
否则就是一次真正的合并。默认把当前提交(_ed489_ 如下所示)和另一个提交(_33104_)以及他们的共同祖父节点(_b325c_)进行一次[三方合并](http://en.wikipedia.org/wiki/Three-way_merge)。结果是先保存当前目录和索引，然后和父节点_33104_一起做一次新提交。
![enter image description here](https://camo.githubusercontent.com/34324bc4bef055192f73d2d51a943bdab75fe93d/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f6d657267652e737667)

### Cherry Pick

cherry-pick命令"复制"一个提交节点并在当前分支做一次完全一样的新提交。
![enter image description here](https://camo.githubusercontent.com/7c93db068f3ce7fae62e688b5fe34d9cdf3869ff/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f6368657272792d7069636b2e737667)

### Rebase

rebase是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。rebase在当前分支上重演另一个分支的历史，提交历史是线性的。

本质上，这是线性化的自动的 [cherry-pick](#cherry-pick)。
![enter image description here](https://camo.githubusercontent.com/57dc5bb8f5a62f8dc11690845f7888d4f6310c3a/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f7265626173652e737667)
上面的命令都在_topic_分支中进行，而不是_master_分支，在_master_分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。

要限制回滚范围，使用`--onto`选项。下面的命令在_master_分支上重演当前分支从_169a6_以来的最近几个提交，即_2c33a_。
![enter image description here](https://camo.githubusercontent.com/6e20a3870c07f0b27183922423fb9f350a6d500e/687474703a2f2f6d61726b6c6f6461746f2e6769746875622e696f2f76697375616c2d6769742d67756964652f7265626173652d6f6e746f2e737667)

同样有`git rebase --interactive`让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。

---

## 概述

你要知道的第一件事是，`git rebase` 和`git merge` 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。

想象一下，你刚创建了一个专门的分支开发新功能，然后团队中另一个成员在master分支上添加了新的提交。这就会造成提交历史被Fork一份，用Git来协作的开发者应该都很清楚。

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/01.svg)

现在，如果master中新的提交和你的工作是相关的。为了将新的提交并入你的分支，你有两个选择：merge或rebase。

### Merge

将master分支合并到feature分支最简单的办法就是用下面这些命令：

``` 
git checkout feature
git merge master
```

或者，你也可以把它们压缩在一行里。

``` 
git merge master feature
```

feature分支中新的合并提交(merge commit)将两个分支的历史连在了一起。你会得到下面这样的分支结构：

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/02.svg)



Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点（后面会说）。

另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的`git log` 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。

### Rebase

作为merge的替代选择，你可以像下面这样将feature分支并入master分支：

``` 
git checkout feature
git rebase master
```

它会把整个feature分支移动到master分支的后面，有效地把所有master分支上新的提交并入过来。但是，rebase为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/03.svg)

rebase最大的好处是你的项目历史会非常整洁。首先，它不像`git merge` 那样引入不必要的合并提交。其次，如上图所示，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用`git log` 、`git bisect` 和`gitk` 来查看项目历史。

不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。

### 交互式的rebase

交互式的rebase允许你更改并入新分支的提交。这比自动的rebase更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将feature分支并入master分支之前，清理混乱的历史。

把`-i` 传入`git rebase` 选项来开始一个交互式的rebase过程：

``` 
git checkout feature
git rebase -i master
```

它会打开一个文本编辑器，显示所有将被移动的提交：

``` 
pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
```

这个列表定义了rebase将被执行后分支会是什么样的。更改`pick` 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个提交修复了第一个提交中的小问题，你可以用`fixup` 命令把它们合到一个提交中：

``` 
pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
```

保存后关闭文件，Git会根据你的指令来执行rebase，项目历史看上去会是这样：

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/04.svg)

忽略不重要的提交会让你的feature分支的历史更清晰易读。这是`git merge` 做不到的。

## Rebase的黄金法则

当你理解rebase是什么的时候，最重要的就是什么时候 *不能* 用rebase。`git rebase` 的黄金法则便是，绝不要在公共的分支上使用它。

比如说，如果你把master分支rebase到你的feature分支上会发生什么：

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/05.svg)

这次rebase将master分支上的所有提交都移到了feature分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的master上工作。因为rebase引起了新的提交，Git会认为你的master分支和其他人的master已经分叉了。

同步两个master分支的唯一办法是把它们merge到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。

所以，在你运行`git rebase` 之前，一定要问问你自己“有没有别人正在这个分支上工作？”。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如`git revert`）来提交你的更改。不然的话，你可以随心所欲地重写历史。

### 强制推送

如果你想把rebase之后的master分支推送到远程仓库，Git会阻止你这么做，因为两个分支包含冲突。但你可以传入`--force` 标记来强行推送。就像下面一样：

``` 
# 小心使用这个命令！
git push --force
```

它会重写远程的master分支来匹配你仓库中rebase之后的master分支，对于团队中其他成员来说这看上去很诡异。所以，务必小心这个命令，只有当你知道你在做什么的时候再使用。

仅有的几个强制推送的使用场景之一是，当你在想向远程仓库推送了一个私有分支之后，执行了一个本地的清理（比如说为了回滚）。这就像是在说“哦，其实我并不想推送之前那个feature分支的。用我现在的版本替换掉吧。”同样，你要注意没有别人正在这个feature分支上工作。



## 工作流

rebase可以或多或少应用在你们团队的Git工作流中。在这一节中，我们来看看在feature分支开发的各个阶段中，rebase有哪些好处。

第一步是在任何和`git rebase` 有关的工作流中为每一个feature专门创建一个分支。它会给你带来安全使用rebase的分支结构：

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/06.svg)

### 本地清理

在你工作流中使用rebase最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式rebase，你可以保证你feature分支中的每一个提交都是专注和有意义的。你在写代码时不用担心造成孤立的提交——因为你后面一定能修复。

调用`git rebase` 的时候，你有两个基(base)可以选择：上游分支（比如master）或者你feature分支中早先的一个提交。我们在“交互式rebase”一节看到了第一种的例子。后一种在当你只需要修改最新几次提交时也很有用。比如说，下面的命令对最新的3次提交进行了交互式rebase：

``` 
git checkout feature
git rebase -i HEAD~3
```

通过指定`HEAD~3`作为新的基提交，你实际上没有移动分支——你只是将之后的3次提交重写了。注意它不会把上游分支的更改并入到feature分支中。

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/07.svg)

如果你想用这个方法重写整个feature分支，`git merge-base` 命令非常方便地找出feature分支开始分叉的基。下面这段命令返回基提交的ID，你可以接下来将它传给`git rebase`：

``` 
git merge-base feature master
```

交互式rebase是在你工作流中引入`git rebase` 的的好办法，因为它只影响本地分支。其他开发者只能看到你已经完成的结果，那就是一个非常整洁、易于追踪的分支历史。

但同样的，这只能用在私有分支上。如果你在同一个feature分支和其他开发者合作的话，这个分支是公开的，你不能重写这个历史。

用带有交互式的rebase清理本地提交，这是无法用`git merge` 命令代替的。

### 将上游分支上的更改并入feature分支

在概览一节，我们看到了feature分支如何通过`git merge` 或`git rebase` 来并入上游分支。merge是保留你完整历史的安全选择，rebase将你的feature分支移动到master分支后面，创建一个线性的历史。

`git rebase` 的用法和本地清理非常类似（而且可以同时使用），但之间并入了master上的上游更改。

记住，rebase到远程分支而不是master也是完全合法的。当你和另一个开发者在同一个feature分之上协作的时候，你会用到这个用法，将他们的更改并入你的项目。

比如说，如果你和另一个开发者——John——往feature分支上添加了几个提交，在从John的仓库中fetch之后，你的仓库可能会像下面这样：

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/08.svg)

就和并入master上的上游更改一样，你可以这样解决这个Fork：要么merge你的本地分支和John的分支，要不把你的本地分支rebase到John的分支后面。

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/09.svg)

注意，这里的rebase没有违反Rebase黄金法则，因为只有你的本地分支上的commit被移动了，之前的所有东西都没有变。这就像是在说“把我的改动加到John的后面去”。在大多数情况下，这比通过合并提交来同步远程分支更符合直觉。

默认情况下，`git pull` 命令会执行一次merge，但你可以传入`--rebase` 来强制它通过rebase来整合远程分支。

### 用Pull Request进行审查

如果你将pull request作为你代码审查过程中的一环，你需要避免在创建pull request之后使用`git rebase`。只要你发起了pull request，其他开发者能看到你的代码，也就是说这个分支变成了公共分支。重写历史会造成Git和你的同事难以找到这个分支接下来的任何提交。

来自其他开发者的任何更改都应该用`git merge` 而不是`git rebase` 来并入。

因此，在提交pull request前用交互式的rebase进行代码清理通常是一个好的做法。

### 并入通过的功能分支

如果某个功能被你们团队通过了，你可以选择将这个分支rebase到master分支之后，或是使用`git merge` 来将这个功能并入主代码库中。

这和将上游改动并入feature分支很相似，但是你不可以在master分支重写提交，你最后需要用`git merge` 来并入这个feature。但是，在merge之前执行一次rebase，你可以确保merge是一直向前的，最后生成的是一个完全线性的提交历史。这样你还可以加入pull request之后的提交。

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/merging-vs-rebasing/10.svg)

如果你还没有完全熟悉`git rebase`，你还可以在一个临时分支中执行rebase。这样的话，如果你意外地弄乱了你feature分支的历史，你还可以查看原来的分支然后重试。

比如说：

``` 
git checkout feature
git checkout -b temporary-branch
git rebase -i master
# [清理目录]
git checkout master
git merge temporary-branch
```

## 总结

你使用rebase之前需要知道的知识点都在这了。如果你想要一个干净的、线性的提交历史，没有不必要的合并提交，你应该使用`git rebase` 而不是`git merge` 来并入其他分支上的更改。

另一方面，如果你想要保存项目完整的历史，并且避免重写公共分支上的commit， 你可以使用`git merge`。两种选项都很好用，但至少你现在多了`git rebase`这个选择。


## 提交层面的操作

你传给`git reset`和`git checkout`的参数决定了它们的作用域。如果你没有包含文件路径，这些操作对所有提交生效。我们这一节要探讨的就是提交层面的操作。注意，`git revert`没有文件层面的操作。

### Reset

在提交层面上，reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。比如，下面这两条命令让hotfix分支向后回退了两个提交。

``` 
git checkout hotfix
git reset HEAD~2
```

hotfix分支末端的两个提交现在变成了悬挂提交。也就是说，下次Git执行垃圾回收的时候，这两个提交会被删除。换句话说，如果你想扔掉这两个提交，你可以这么做。reset操作如下图所示：

![把hotfix分支reset到HEAD~2](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/02.svg)

如果你的更改还没有共享给别人，`git reset`是撤销这些更改的简单方法。当你开发一个功能的时候发现『糟糕，我做了什么？我应该重新来过！』时，reset就像是go-to命令一样。

除了在当前分支上操作，你还可以通过传入这些标记来修改你的缓存区或工作目录：

- --soft – 缓存区和工作目录都不会被改变
- --mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响
- --hard – 缓存区和工作目录都同步到你指定的提交

把这些标记想成定义`git reset`操作的作用域就容易理解多了。

![git rese的定义域](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/03.svg)

这些标记往往和HEAD作为参数一起使用。比如，`git reset --mixed HEAD` 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。另一方面，如果你想完全舍弃你没有提交的改动，你可以使用`git reset --hard HEAD`。这是`git reset`最常用的两种用法。

当你传入HEAD以外的其他提交的时候要格外小心，因为reset操作会重写当前分支的历史。正如Rebase黄金法则所说的，在公共分支上这样做可能会引起严重的后果。

### Checkout

你应该已经非常熟悉提交层面的`git checkout`。当传入分支名时，可以切换到那个分支。

``` 
git checkout hotfix
```

上面这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。因为这可能会覆盖本地的修改，Git强制你提交或者缓存工作目录中的所有更改，不然在checkout的时候这些更改都会丢失。和`git reset`不一样的是，`git checkout`没有移动这些分支。

![将 HEAD 从 master 移到 hotfix](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/04.svg)

除了分支之外，你还可以传入提交的引用来checkout到任意的提交。这和checkout到另一个分支是完全一样的：把HEAD移动到特定的提交。比如，下面这个命令会checkout到当前提交的祖父提交。

``` 
git checkout HEAD~2
```

![将HEAD移动到任意commit](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/05.svg)

这对于快速查看项目旧版本来说非常有用。但如果你当前的HEAD没有任何分支引用，那么这会造成HEAD分离。这是非常危险的，如果你接着添加新的提交，然后切换到别的分支之后就没办法回到之前添加的这些提交。因此，在为分离的HEAD添加新的提交的时候你应该创建一个新的分支。

### Revert

Revert撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。

``` 
git checkout hotfix
git revert HEAD~2
```

如下图所示：

![revert到倒数第二个commit](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/06.svg)

相比`git reset`，它不会改变现在的提交历史。因此，`git revert`可以用在公共分支上，`git reset`应该用在私有分支上。

你也可以把`git revert`当作撤销已经提交的更改，而`git reset HEAD`用来撤销没有提交的更改。

就像`git checkout` 一样，`git revert` 也有可能会重写文件。所以，Git会在你执行revert之前要求你提交或者缓存你工作目录中的更改。

## 文件层面的操作

`git reset`和`git checkout` 命令也接受文件路径作为参数。这时它的行为就大为不同了。它不会作用于整份提交，参数将它限制于特定文件。

### Reset

当检测到文件路径时，`git reset` 将缓存区同步到你指定的那个提交。比如，下面这个命令会将倒数第二个提交中的foo.py加入到缓存区中，供下一个提交使用。

``` 
git reset HEAD~2 foo.py
```

和提交层面的`git reset`一样，通常我们使用HEAD而不是某个特定的提交。运行`git reset HEAD foo.py` 会将当前的foo.py从缓存区中移除出去，而不会影响工作目录中对foo.py的更改。

![将一个文件从commit历史中移动到stage缓存中](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/07.svg)



--soft、--mixed和--hard对文件层面的`git reset`毫无作用，因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。

### Checkout

Checkout一个文件和带文件路径`git reset` 非常像，除了它更改的是工作目录而不是缓存区。不像提交层面的checkout命令，它不会移动HEAD引用，也就是你不会切换到别的分支上去。

![将文件从提交历史移动到工作目录中](https://www.atlassian.com/git/images/tutorials/advanced/resetting-checking-out-and-reverting/08.svg)

比如，下面这个命令将工作目录中的foo.py同步到了倒数第二个提交中的foo.py。

``` 
git checkout HEAD~2 foo.py
```

和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。

如果你缓存并且提交了checkout的文件，它具备将某个文件回撤到之前版本的效果。注意它撤销了这个文件后面所有的更改，而`git revert` 命令只撤销某个特定提交的更改。

和`git reset` 一样，这个命令通常和HEAD一起使用。比如`git checkout HEAD foo.py`等同于舍弃foo.py没有缓存的更改。这个行为和`git reset HEAD --hard`很像，但只影响特定文件。

## 总结

你现在已经掌握了Git仓库中撤销更改的所有工具。`git reset`、`git checkout`、和 `git revert`命令比较容易混淆，但当你想起它们对工作目录、缓存区和提交历史的不同影响，就会容易判断现在应该用哪个命令。

下面这个表格总结了这些命令最常用的使用场景。记得经常对照这个表格，因为你使用Git时一定会经常用到。

|      命令      | 作用域  | 常用情景              |
| :----------: | :--: | :---------------- |
|  git reset   | 提交层面 | 在私有分支上舍弃一些没有提交的更改 |
|  git reset   | 文件层面 | 将文件从缓存区中移除        |
| git checkout | 提交层面 | 切换分支或查看旧版本        |
| git checkout | 文件层面 | 舍弃工作目录中的更改        |
|  git revert  | 提交层面 | 在公共分支上回滚更改        |
|  git revert  | 文件层面 | （然而并没有）           |


## 格式化Log输出

首先，这篇文章会展示几种`git log`格式化输出的例子。大多数例子只是通过标记向`git log`请求或多或少的信息。

如果你不喜欢默认的`git log`格式，你可以用`git config`的别名功能来给你想要的格式创建一个快捷方式。

### Oneline

`--oneline`标记把每一个提交压缩到了一行中。它默认只显示提交ID和提交信息的第一行。`git log --oneline`的输出一般是这样的：

``` 
0e25143 Merge branch 'feature'
ad8621a Fix a bug in the feature
16b36c6 Add a new feature
23ad9ad Add the initial code base
```

它对于获得项目的总体情况很有帮助。

### Decorate

很多时候，知道每个提交关联的分支或者标签很有用。`--decorate`标记让`git log`显示指向这个提交的所有引用（比如说分支、标签等）。

这可以和另一个配置项一起使用。比如，执行`git log --oneline --decorate` 会将提交历史格式化成这样：

``` 
0e25143 (HEAD, master) Merge branch 'feature'
ad8621a (feature) Fix a bug in the feature
16b36c6 Add a new feature
23ad9ad (tag: v0.9) Add the initial code base
```

在这个例子中，你（通过HEAD标记）可以看到最上面那个提交已经被checkout了，而且它还是master分支的尾端。第二个提交有另一个feature分支指向它，以及最后那个提交带有v0.9标签。

分支、标签、HEAD还有提交历史是你Git仓库中包含的所有信息。因此，这个命令让你更完整地观察项目结构。

### Diff

`git log`提供了很多选项来显示两个提交之间的差异。其中最常用的两个是`--stat`和`-p`。

`--stat`选项显示每次提交的文件增删数量（注意：修改一行记作增加一行且删去一行），当你想要查看提交引入的变化时这会非常有用。比如说，下面这个提交在hello.py文件中增加了67行，删去了38行。

``` 
commit f2a238924e89ca1d4947662928218a06d39068c3
Author: John <john@example.com>
Date:   Fri Jun 25 17:30:28 2014 -0500

    Add a new feature

 hello.py | 105 ++++++++++++++++++++++++-----------------
 1 file changed, 67 insertion(+), 38 deletions(-)
```

文件名后面+和-的数量是这个提交造成的更改中增删的相对比例。它给你一个直观的感觉，关于这次提交有多少改动。如果你想知道每次提交删改的绝对数量，你可以将`-p` 选项传入`git log` 。这样提交所有的删改都会被输出：

``` 
commit 16b36c697eb2d24302f89aa22d9170dfe609855b
Author: Mary <mary@example.com>
Date:   Fri Jun 25 17:31:57 2014 -0500

    Fix a bug in the feature

diff --git a/hello.py b/hello.py
index 18ca709..c673b40 100644
--- a/hello.py
+++ b/hello.py
@@ -13,14 +13,14 @@ B
-print("Hello, World!")
+print("Hello, Git!")
```

对于改动很多的提交来说，这个输出会变得又长又大。一般来说，当你输出所有删改的时候，你是想要查找某一具体的改动，这时你就要用到`pickaxe` 选项。

### Shortlog

`git shortlog`是一种特殊的`git log` ，它是为创建发布声明设计的。它把每个提交按作者分类，显示提交信息的第一行。这样可以容易地看到谁做了什么。

比如说，两个开发者为项目贡献了5个提交，那么`git shortlog` 输出会是这样的：

``` 
Mary (2):
      Fix a bug in the feature
      Fix a serious security hole in our framework

John (3):
      Add the initial code base
      Add a new feature
      Merge branch 'feature'
```

默认情况下，`git shortlog`把输出按作者名字排序，但你可以传入`-n`选项来按每个作者提交数量排序。

### Graph

`--graph` 选项绘制一个ASCII图像来展示提交历史的分支结构。它经常和 `--oneline`和 `--decorate`两个选项一起使用，这样会更容易查看哪个提交属于哪个分支：

``` 
git log --graph --oneline --decorate
For a simple repository with just 2 branches, this will produce the following:

*   0e25143 (HEAD, master) Merge branch 'feature'
|\  
| * 16b36c6 Fix a bug in the new feature
| * 23ad9ad Start a new feature
* | ad8621a Fix a critical security issue
|/  
* 400e4b7 Fix typos in the documentation
* 160e224 Add the initial code base
```

星号表明这个提交所在的分支，所以上图的意思是`23ad9ad`和`16b36c6`这两个提交在topic分支上，其余的在master分支上。

虽然这对简单的项目来说是个很好用的选择，但你可能会更喜欢gitk或SourceTree这些更强大的可视化工具来分析大型项目。

### 自定义格式

对于其他的`git log`格式需求，你都可以使用`--pretty=format:"<string>"`选项。它允许你使用像printf一样的占位符来输出提交。

比如，下面命令中的`%cn`、`%h` 和`%cd`这三种占位符会被分别替换为作者名字、缩略标识和提交日期。

``` 
git log --pretty=format:"%cn committed %h on %cd"
This results in the following format for each commit:

John committed 400e4b7 on Fri Jun 24 12:30:04 2014 -0500
John committed 89ab2cf on Thu Jun 23 17:09:42 2014 -0500
Mary committed 180e223 on Wed Jun 22 17:21:19 2014 -0500
John committed f12ca28 on Wed Jun 22 13:50:31 2014 -0500
```

完整的占位符清单可以在文档中找到。

除了让你只看到关注的信息，这个`--pretty=format:"<string>"` 选项在你想要在另一个命令中使用日志内容是尤为有用的。

## 过滤提交历史

格式化提交输出只是`git log`其中的一个用途。另一半是理解如何浏览整个提交历史。接下来的文章会介绍如何用`git log`选择项目历史中的特定提交。所有的用法都可以和上面讨论过的格式化选项结合起来。

### 按数量

`git log`最基础的过滤选项是限制显示的提交数量。当你只对最近几次提交感兴趣时，它可以节省你一页一页查看的时间。

你可以在后面加上`-<n>`选项。比如说，下面这个命令会显示最新的3次提交：

``` 
git log -3
```

### 按日期

如果你想要查看某一特定时间段内的提交，你可以使用`--after` 或 `--before` 标记来按日期筛选。它们都接受好几种日期格式作为参数。比如说，下面的命令会显示2014年7月1日后（含）的提交：

``` 
git log --after="2014-7-1"
```

你也可以传入相对的日期，比如一周前（"`1 week ago`"）或者昨天（"`yesterday`"）：

``` 
get log --after="yesterday"
```

你可以同时提供`--before` 和 `--after` 来检索两个日期之间的提交。比如，为了显示2014年7月1日到2014年7月4日之间的提交，你可以这么写：

``` 
git log --after="2014-7-1" --before="2014-7-4"
```

注意`--since` 、`--until` 标记和`--after` 、`--before`标记分别是等价的。

### 按作者

当你只想看某一特定作者的提交的时候，你可以使用`--author`标记。它接受正则表达式，返回所有作者名字满足这个规则的提交。如果你知道那个作者的确切名字你可以直接传入文本字符串：

``` 
git log --author="John"
```

它会显示所有作者叫John的提交。作者名不一定是全匹配，只要包含那个子串就会匹配。

你也可以用正则表达式来创建更复杂的检索。比如，下面这个命令检索名叫Mary或John的作者的提交。

``` 
git log --author="John\|Mary"
```

注意作者的邮箱地址也算作是作者的名字，所以你也可以用这个选项来按邮箱检索。

如果你的工作流区分提交者和作者，`--committer`也能以相同的方式使用。

### 按提交信息

按提交信息来过滤提交，你可以使用`--grep`标记。它和上面的`--author`标记差不多，只不过它搜索的是提交信息而不是作者。

比如说，你的团队规范要求在提交信息中包括相关的issue编号，你可以用下面这个命令来显示这个issue相关的所有提交：

``` 
git log --grep="JRA-224:"
```

你也可以传入`-i`参数来忽略大小写匹配。

### 按文件

很多时候，你只对某个特定文件的更改感兴趣。为了显示某个特定文件的历史，你只需要传入文件路径。比如说，下面这个命令返回所有和`foo.py`和`bar.py`文件相关的提交：

``` 
git log -- foo.py bar.py
```

`--`告诉`git log`接下来的参数是文件路径而不是分支名。如果分支名和文件名不可能冲突，你可以省略`--`。

### 按内容

我们还可以根据源代码中某一行的增加和删除来搜索提交。这被称为pickaxe，它接受形如`-S"<string>"`的参数。比如说，当你想要知道`Hello, World!`字符串是什么时候加到项目中哪个文件中去的，你可以使用下面这个命令：

``` 
git log -S "Hello, World!"
```

如果你想用正则表达式而不是字符串来搜索，你可以使用`-G"<regex>"`标记。

这是一个非常强大的调试工具，它能让你定位到所有影响代码中特定一行的提交。它甚至可以让你看到某一行是什么时候复制或者移动到另一个文件中去的。

### 按范围

你可以传入范围来筛选提交。这个范围由下面这样的格式指定，其中`<since>`和`<until>`是提交的引用：

``` 
git log <since>..<until>
```

这个命令在你使用分支引用作为参数时特别有用。这是显示两个分支之间区别最简单的方式。看看下面这个命令：

``` 
git log master..feature
```

其中的master..feature范围包含了在feature分支而不在master分支中所有的提交。换句话说，这个命令可以看出从master分支fork到feature分支后发生了哪些变化。它可以这样可视化：

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/git-log/01.svg)

注意如果你更改范围的前后顺序(feature..master)，你会获取到master分支而非feature分支上的所有提交。如果`git log`输出了全部两个分支的提交，这说明你的提交历史已经分叉了。

### 过滤合并提交

`git log`输出时默认包括合并提交。但是，如果你的团队采用强制合并策略（意思是merge你修改的上游分支而不是将你的分支rebase到上游分支），你的项目历史中会有很多外来的提交。

你可以通过`--no-merges`标记来排除这些提交：

``` 
git log --no-merges
```

另一方面，如果你只对合并提交感兴趣，你可以使用`--merges`标记：

``` 
git log --merges
```

它会返回所有包含两个父节点的提交。

## 总结

你现在应该对使用`git log`来格式化输出和选择你要显示的提交的用法比较熟悉了。它允许你查看你项目历史中任何需要的内容。

这些技巧是你Git工具箱中重要的部分，不过注意`git log`往往和其他Git命令连着使用。当你找到了你要的提交，你把它传给`git checkout` 、`git revert`  或是其他控制提交历史的工具。所以，请继续坚持Git高级用法的学习。

# 概述

Git钩子是仓库中特定事件发生时Git自动运行的普通脚本。因此，Git钩子安装和配置也非常容易。

钩子在本地或服务端仓库都可以部署，且只会在仓库中事件发生时被执行。在文章后面我们会具体地研究各种钩子。接下来所讲的配置对本地和服务端钩子都起作用。

### 安装钩子

钩子存在于每个Git仓库的`.git/hooks`目录中。当你初始化仓库时，Git自动生成这个目录和一些示例脚本。当你观察`.git/hooks`时，你会看到下面这些文件：

``` 
applypatch-msg.sample       pre-push.sample
commit-msg.sample           pre-rebase.sample
post-update.sample          prepare-commit-msg.sample
pre-applypatch.sample       update.sample
pre-commit.sample
```

这里已经包含了大部分可用的钩子了，但是`.sample`拓展名防止它们默认被执行。为了安装一个钩子，你只需要去掉`.sample`拓展名。或者你要写一个新的脚本，你只需添加一个文件名和上述匹配的新文件，去掉`.sample`拓展名。

比如说，试试安装一个`prepare-commit-msg`钩子。去掉脚本的`.sample`拓展名，在文件中加上下面这两行：

``` 
#!/bin/sh

echo "# Please include a useful commit message!" > $1
```

钩子需要能被执行，所以如果你创建了一个新的脚本文件，你需要修改它的文件权限。比如说，为了确保`prepare-commit-msg`可执行，运行下面这个命令：

``` 
chmod +x prepare-commit-msg
```

接下来你每次运行`git commit`时，你会看到默认的提交信息都被替换了。我们会在“准备提交信息”一节中细看它是如何工作的。现在我们已经可以定制Git的内部功能，你只需要坐和放宽。

内置的样例脚本是非常有用的参考资料，因为每个钩子传入的参数都有非常详细的说明（不同钩子不一样）。

### 脚本语言

内置的脚本大多是shell和PERL语言的，但你可以使用任何脚本语言，只要它们最后能编译到可执行文件。每次脚本中的`#!/bin/sh`定义了你的文件将被如何解释。比如，使用其他语言时你只需要将path改为你的解释器的路径。

比如说，你可以在`prepare-commit-msg`中写一个可执行的Python脚本。下面这个钩子和上一节的shell脚本做的事完全一样。

``` 
#!/usr/bin/env python

import sys, os

commit_msg_filepath = sys.argv[1]
with open(commit_msg_filepath, 'w') as f:
    f.write("# Please include a useful commit message!")
```

注意第一行改成了Python解释器的路径。此外，这里用`sys.argv[1]`而不是`$1`来获取第一个参数（这个也后面再讲）。

这个特性非常强大，因为你可以用任何你喜欢的语言来编写Git钩子。

### 钩子的作用域

对于任何Git仓库来说钩子都是本地的，而且它不会随着`git clone`一起复制到新的仓库。而且，因为钩子是本地的，任何能接触得到仓库的人都可以修改。

对于开发团队来说，这有很大的影响。首先，你要确保你们成员之间的钩子都是最新的。其次，你也不能强行让其他人用你喜欢的方式提交——你只能鼓励他们这样做。

在开发团队中维护钩子是比较复杂的，因为`.git/hooks`目录不随你的项目一起拷贝，也不受版本控制影响。一个简单的解决办法是把你的钩子存在项目的实际目录中（在`.git` 外）。这样你就可以像其他文件一样进行版本控制。为了安装钩子，你可以在`.git/hooks`中创建一个符号链接，或者简单地在更新后把它们复制到`.git/hooks`目录下。

![enter image description here](https://www.atlassian.com/git/images/tutorials/advanced/git-hooks/02.svg)

作为备选方案，Git同样提供了一个模板目录机制来更简单地自动安装钩子。每次你使用`git init` 或`git clone`时，模板目录文件夹下的所有文件和目录都会被复制到`.git` 文件夹。

所有的下面讲到的本地钩子都可以被更改或者彻底删除，只要你是项目的参与者。这完全取决于你的团队成员想不想用这个钩子。所以记住，最好把Git钩子当成一个方便的开发者工具而不是一个严格强制的开发规范。

也就是说，用服务端钩子来拒绝没有遵守规范的提交是完全可行的。后面我们会再讨论这个问题。

## 本地钩子

本地钩子只影响它们所在的仓库。当你在读这一节的时候，记住开发者可以修改他们本地的钩子，所以不要用它们来推行强制的提交规范。不过，它们确实可以让开发者更易于接受这些规范。

在这一节中，我们会探讨6个最有用的本地钩子：

- pre-commit
- prepare-commit-msg
- commit-msg
- post-commit
- post-checkout
- pre-rebase

前四个钩子让你介入完整的提交生命周期，后两个允许你执行一些额外的操作，分别为`git checkout`和`git rebase`的安全检查。

所有带`pre-` 的钩子允许你修改即将发生的操作，而带`post-` 的钩子只能用于通知。

我们也会看到处理钩子的参数和用底层Git命令获取仓库信息的实用技巧。

### pre-commit

`pre-commit`脚本在每次你运行`git commit`命令时，Git向你询问提交信息或者生产提交对象时被执行。你可以用这个钩子来检查即将被提交的代码快照。比如说，你可以运行一些自动化测试，保证这个提交不会破坏现有的功能。

`pre-commit`不需要任何参数，以非0状态退出时将放弃整个提交。让我们看一个简化了的（和更详细的）内置`pre-commit`钩子。只要检测到不一致时脚本就放弃这个提交，就像`git diff-index`命令定义的那样（只要词尾有空白字符、只有空白字符的行、行首一个tab后紧接一个空格就被认为错误）。

``` 
#!/bin/sh

# 检查这是否是初始提交
if git rev-parse --verify HEAD >/dev/null 2>&1
then
    echo "pre-commit: About to create a new commit..."
    against=HEAD
else
    echo "pre-commit: About to create the first commit..."
    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

# 使用git diff-index来检查空白字符错误
echo "pre-commit: Testing for whitespace errors..."
if ! git diff-index --check --cached $against
then
    echo "pre-commit: Aborting commit due to whitespace errors"
    exit 1
else
    echo "pre-commit: No whitespace errors :)"
    exit 0
fi
```

使用`git diff-index`时我们要指出和哪次提交进行比较。一般来说是HEAD，但HEAD在创建第一次提交时不存在，所以我们的第一个任务是解决这个极端情形。我们通过`git rev-parse --verify`来检查HEAD是否是一个合法的引用。`>/dev/null 2>&1`这部分屏蔽了`git rev-parse`任何输出。HEAD或者一个新的提交对象被储存在`against`变量中供`git diff-index`使用。`4b825d...`这个哈希字串代表一个空白提交的ID。

`git diff-index --cached`命令将提交和缓存区比较。通过传入`-check`选项，我们要求它在更改引入空白字符错误时警告我们。如果它这么做了，我们返回状态1来放弃这次提交，否则返回状态0，提交工作流正常进行。

这只是`pre-commit`的其中一个例子。它恰好使用了已有的Git命令来根据提交带来的更改进行测试，但你可以在`pre-commit`中做任何你想做的事，比如执行其它脚本、运行第三方测试集、用Lint检查代码风格。



### prepare-commit-msg

`prepare-commit-msg`钩子在`pre-commit`钩子在文本编辑器中生成提交信息之后被调用。这被用来方便地修改自动生成的squash或merge提交。

`prepare-commit-msg`脚本的参数可以是下列三个：

- 包含提交信息的文件名。你可以在原地更改提交信息。
- 提交类型。可以是信息（`-m`或`-F`选项），模板（`-t`选项），merge（如果是个合并提交）或squash（如果这个提交插入了其他提交）。
- 相关提交的SHA1哈希字串。只有当`-c`，`-C`，或`--amend`选项出现时才需要。

和`pre-commit`一样，以非0状态退出会放弃提交。

我们已经看过一个修改提交信息的简单例子，现在我们来看一个更有用的脚本。使用issue跟踪器时，我们通常在单独的分支上处理issue。如果你在分支名中包含了issue编号，你可以使用`prepare-commit-msg`钩子来自动地将它包括在那个分支的每个提交信息中。

``` 
#!/usr/bin/env python

import sys, os, re
from subprocess import check_output

# 收集参数
commit_msg_filepath = sys.argv[1]
if len(sys.argv) > 2:
    commit_type = sys.argv[2]
else:
    commit_type = ''
if len(sys.argv) > 3:
    commit_hash = sys.argv[3]
else:
    commit_hash = ''

print "prepare-commit-msg: File: %s\nType: %s\nHash: %s" % (commit_msg_filepath, commit_type, commit_hash)

# 检测我们所在的分支
branch = check_output(['git', 'symbolic-ref', '--short', 'HEAD']).strip()
print "prepare-commit-msg: On branch '%s'" % branch

# 用issue编号生成提交信息
if branch.startswith('issue-'):
    print "prepare-commit-msg: Oh hey, it's an issue branch."
    result = re.match('issue-(.*)', branch)
    issue_number = result.group(1)

    with open(commit_msg_filepath, 'r+') as f:
        content = f.read()
        f.seek(0, 0)
        f.write("ISSUE-%s %s" % (issue_number, content))
```

首先，上面的`prepare-commit-msg`钩子告诉你如何收集传入脚本的所有参数。接下来，它调用了`git symbolic-ref --short HEAD`来获取对应HEAD的分支名。如果分支名以`issue-`开头，它会重写提交信息文件，在第一行加上issue编号。比如你的分支名`issue-224` ，下面的提交信息将会生成：

``` 
ISSUE-224 

# Please enter the commit message for your changes. Lines starting 
# with '#' will be ignored, and an empty message aborts the commit. 
# On branch issue-224 
# Changes to be committed: 
#   modified:   test.txt
```

有一点要记住的是即使用户用`-m`传入提交信息，`prepare-commit-msg` 也会运行。也就是说，上面这个脚本会自动插入`ISSUE-[#]`字符串，而用户无法更改。你可以检查第二个参数是否是提交类型来处理这个情况。

但是，如果没有`-m`选项，`prepare-commit-msg`钩子允许用户修改生成后的提交信息。所以脚本的目的是为了方便，而不是推行强制的提交信息规范。如果你要这么做，你需要下一节所讲的`commit-msg`钩子。

### commit-msg

`commit-msg`钩子和`prepare-commit-msg`钩子很像，但它会在用户输入提交信息之后被调用。这适合用来提醒开发者他们的提交信息不符合你团队的规范。

传入这个钩子唯一的参数是包含提交信息的文件名。如果它不喜欢用户输入的提交信息，它可以在原地修改这个文件（和`prepare-commit-msg`一样），或者它会以非0状态退出，放弃这个提交。

比如说，下面这个脚本确认用户没有删除`prepare-commit-msg`脚本自动生成的`ISSUE-[#]`字符串。

``` 
#!/usr/bin/env python

import sys, os, re
from subprocess import check_output

# 收集参数
commit_msg_filepath = sys.argv[1]

# 检测所在的分支
branch = check_output(['git', 'symbolic-ref', '--short', 'HEAD']).strip()
print "commit-msg: On branch '%s'" % branch

# 检测提交信息，判断是否是一个issue提交
if branch.startswith('issue-'):
    print "commit-msg: Oh hey, it's an issue branch."
    result = re.match('issue-(.*)', branch)
    issue_number = result.group(1)
    required_message = "ISSUE-%s" % issue_number

    with open(commit_msg_filepath, 'r') as f:
        content = f.read()
        if not content.startswith(required_message):
            print "commit-msg: ERROR! The commit message must start with '%s'" % required_message
            sys.exit(1)
```

虽然用户每次创建提交时，这个脚本都会运行。但你还是应该避免做检查提交信息之外的事情。如果你需要通知其他服务一个快照已经被提交了，你应该使用`post-commit`这个钩子。

### post-commit

`post-commit`钩子在`commit-msg`钩子之后立即被运行 。它无法更改`git commit`的结果，所以这主要用于通知用途。

这个脚本没有参数，而且退出状态不会影响提交。对于大多数`post-commit`脚本来说，你只是想访问你刚刚创建的提交。你可以用`git rev-parse HEAD`来获得最近一次提交的SHA1哈希字串，或者你可以用`git log -l HEAD`获取完整的信息。

比如说，如果你需要每次提交快照时向老板发封邮件（也许对于大多数工作流来说这不是个好的想法），你可以加上下面这个`post-commit`钩子。

``` 
#!/usr/bin/env python

import smtplib
from email.mime.text import MIMEText
from subprocess import check_output

# 获得新提交的git log --stat输出
log = check_output(['git', 'log', '-1', '--stat', 'HEAD'])

# 创建一个纯文本的邮件内容
msg = MIMEText("Look, I'm actually doing some work:\n\n%s" % log)

msg['Subject'] = 'Git post-commit hook notification'
msg['From'] = 'mary@example.com'
msg['To'] = 'boss@example.com'

# 发送信息
SMTP_SERVER = 'smtp.example.com'
SMTP_PORT = 587

session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
session.ehlo()
session.starttls()
session.ehlo()
session.login(msg['From'], 'secretPassword')

session.sendmail(msg['From'], msg['To'], msg.as_string())
session.quit()
```

你虽然可以用`post-commit`来触发本地的持续集成系统，但大多数时候你想用的是`post-receive`这个钩子。它运行在服务端而不是用户的本地机器，它同样在任何开发者推送代码时运行。那里更适合你进行持续集成。

### post-checkout

`post-checkout`钩子和`post-commit`钩子很像，但它在你用`git checkout`查看引用的时候被调用。这是用来清理你的工作目录中可能会令人困惑的生成文件。

这个钩子接受三个参数，它的返回状态不影响`git checkout`命令。

- HEAD前一次提交的引用
- 新的HEAD的引用
- 1或0，分别代表是分支checkout还是文件checkout。

Python程序员经常遇到的问题是切换分支后那些之前生成的`.pyc`文件。解释器有时使用`.pyc`而不是`.py`文件。为了避免歧义，你可以在每次用`post-checkout`切换到新的分支的时候，删除所有`.pyc`文件。

``` 
#!/usr/bin/env python

import sys, os, re
from subprocess import check_output

# 收集参数
previous_head = sys.argv[1]
new_head = sys.argv[2]
is_branch_checkout = sys.argv[3]

if is_branch_checkout == "0":
    print "post-checkout: This is a file checkout. Nothing to do."
    sys.exit(0)

print "post-checkout: Deleting all '.pyc' files in working directory"
for root, dirs, files in os.walk('.'):
    for filename in files:
        ext = os.path.splitext(filename)[1]
        if ext == '.pyc':
            os.unlink(os.path.join(root, filename))
```

钩子脚本当前的工作目录总是位于仓库的根目录下，所以`os.walk('.')`调用遍历了仓库中所有文件。接下来，我们检查它的拓展名，如果是`.pyc`就删除它。

通过`post-checkout`钩子，你还可以根据你切换的分支来来更改工作目录。比如说，你可以在代码库外面使用一个插件分支来储存你所有的插件。如果这些插件需要很多二进制文件而其他分支不需要，你可以选择只在插件分支上build。

### pre-rebase

`pre-rebase`钩子在`git rebase`发生更改之前运行，确保不会有什么糟糕的事情发生。

这个钩子有两个参数：frok之前的上游分支，将要rebase的下游分支。如果rebase当前分支则第二个参数为空。以非0状态退出会放弃这次rebase。

比如说，如果你想彻底禁用rebase操作，你可以使用下面的`pre-rebase`脚本：

``` 
#!/bin/sh

# 禁用所有rebase
echo "pre-rebase: Rebasing is dangerous. Don't do it."
exit 1
```

每次运行`git rebase`，你都会看到下面的信息：

``` 
pre-rebase: Rebasing is dangerous. Don't do it.
The pre-rebase hook refused to rebase.
```

内置的`pre-rebase.sample`脚本是一个更复杂的例子。它在何时阻止rebase这方面更加智能。它会检查你当前的分支是否已经合并到了下一个分支中去（也就是主分支）。如果是的话，rebase可能会遇到问题，脚本会放弃这次rebase。

# 服务端钩子

服务端钩子和本地钩子几乎一样，只不过它们存在于服务端的仓库中（比如说中心仓库，或者开发者的公共仓库）。当和官方仓库连接时，其中一些可以用来拒绝一些不符合规范的提交。

这节中我们要讨论下面三个服务端钩子：

- pre-receive
- update
- post-receive

这些钩子都允许你对`git push`的不同阶段做出响应。

服务端钩子的输出会传送到客户端的控制台中，所以给开发者发送信息是很容易的。但你要记住这些脚本在结束完之前都不会返回控制台的控制权，所以你要小心那些长时间运行的操作。

### pre-receive

`pre-receive`钩子在有人用`git push`向仓库推送代码时被执行。它只存在于远端仓库中，而不是原来的仓库中。

这个钩子在任意引用被更新钱被执行，所以这是强制推行开发规范的好地方。如果你不喜欢推送的那个人（多大仇= =），提交信息的格式，或者提交的更改，你都可以拒绝这次提交。虽然你不能阻止开发者写出糟糕的代码，但你可以用`pre-receive`防止这些代码流入官方的代码库。

这个脚本没有参数，但每一个推送上来的引用都会以下面的格式传入脚本的单独一行：

``` 
<old-value> <new-value> <ref-name>
```

你可以看到这个钩子做了非常简单的事，就是读取推送上来的引用并且把它们打印出来。

``` 
#!/usr/bin/env python

import sys
import fileinput

# 读取用户试图更新的所有引用
for line in fileinput.input():
    print "pre-receive: Trying to push ref: %s" % line

# 放弃推送
# sys.exit(1)
```

这和其它钩子相比略微有些不同，因为信息是通过标准输入而不是命令行传入的。在远端仓库的`.git/hooks`中加上这个脚本，推送到master分支，你会看到下面这些信息打印出来：

``` 
b6b36c697eb2d24302f89aa22d9170dfe609855b 85baa88c22b52ddd24d71f05db31f4e46d579095 refs/heads/master
```

你可以用SHA1哈希字串，或者底层的Git命令，来检查将要引入的更改。一些常见的使用包括：

- 拒绝将上游分支rebase的更改
- 防止错综复杂的合并（非快速向前，会造成项目历史非线性）
- 检查用户是否有正确的权限来做这些更改（大多用于中心化的Git工作流中）
- 如果多个引用被推送，在`pre-receive`中返回非0状态，拒绝所有提交。如果你想一个个接受或拒绝分支，你需要使用`update`钩子

### update

`update`钩子在`pre-receive`之后被调用，用法也差不多。它也是在实际更新前被调用的，但它可以分别被每个推送上来的引用分别调用。也就是说如果用户尝试推送到4个分支，`update`会被执行4次。和`pre-receive`不一样，这个钩子不需要读取标准输入。事实上，它接受三个参数：

- 更新的引用名称
- 引用中存放的旧的对象名称
- 引用中存放的新的对象名称

这些信息和`pre-receive`相同，但因为每次引用都会分别触发更新，你可以拒绝一些引用而接受另一些。

``` 
#!/usr/bin/env python

import sys

branch = sys.argv[1]
old_commit = sys.argv[2]
new_commit = sys.argv[3]

print "Moving '%s' from %s to %s" % (branch, old_commit, new_commit)

# 只放弃当前分支的推送
# sys.exit(1)
```

上面这个钩子简单地输出了分支和新旧提交的哈希字串。当你向远程仓库推送超过一个分支时，你可以看到每个分支都有输出。

### post-receive

`post-receive`钩子在成功推送后被调用，适合用于发送通知。对很多工作流来说，这是一个比`post-commit`更好的发送通知的地方，因为这些更改在公共的服务器而不是用户的本地机器上。给其他开发者发送邮件或者触发一个持续集成系统都是`post-receive`常用的操作。

这个脚本没有参数，但和`pre-receive`一样通过标准输入读取。

## 总结

在这篇文章中，我们学习了如果用Git钩子来修改内部行为，当仓库中特定的事件发生时接受消息。钩子是存在于`git/hooks`仓库中的普通脚本，因此也非常容易安装和定制。

我们还看了一些常用的本地和服务端的钩子。这使得我们能够介入到整个开发生命周期中去。我们现在知道了如何在创建提交或推送的每个阶段执行自定义的操作。有了这些简单的脚本知识，你就可以对Git仓库为所欲为了 :)


![引用一次提交的各种方式](https://www.atlassian.com/git/images/tutorials/advanced/refs-and-the-reflog/01.svg)

## 哈希字串

引用一个提交最直接的方式是通过SHA-1的哈希字串，这是每个提交唯一的ID。你可以在`git log`的输出中找到提交的哈希字串。

``` 
commit 0c708fdec272bc4446c6cabea4f0022c2b616eba
Author: Mary Johnson <mary@example.com>
Date:   Wed Jul 9 16:37:42 2014 -0500

    一些提交信息
```

在Git命令中传递时，你只需要提供足以确定那个提交的哈希子串即可。比如，你可以这样用`git show`的命令显示上面的提交：

``` 
git show 0c708f
```

有时，我们需要把分支、标签或者其他间接的引用转变成对应提交的哈希。`git rev-parse`命令正是你需要的。下面这个命令返回master分支提交的哈希字串：

``` 
git rev-parse master
```

当你写的自定义脚本中需要将提交引用作为参数时，这个命令非常有用。你可以让`git rev-parse`帮你处理转换，而不用手动做这件事。

## 引用

ref是提交的间接引用。你可以把它当做哈希字串的别名，但对用户更友好。这就是Git内部表示分支和标签的机制。

引用以一段普通的文本存在于`.git/refs`目录中，就是我们平时说的那个`.git`。你去`.git/refs`文件夹查看仓库中的引用。你可以看到下面这样的结构，但具体的文件取决于你的仓库中有什么分支和标签，以及你的远程仓库。

``` 
.git/refs/
    heads/
        master
        some-feature
    remotes/
        origin/
            master
    tags/
        v0.9
```

`heads`目录定义了你本地仓库中的所有分支。每一个文件名和你的分支名一一对应，文件中包含一个提交的哈希字串。这个就是分支顶端的所在位置。为了验证这一点，试试在Git根目录运行下面这两个命令：

``` 
# 输出`refs/heads/master`文件内容
cat .git/refs/heads/master

# 查看`master`分支尾端的提交
git log -1 master
```

`cat`命令返回的哈希字串和`git log`命令显示的哈希字串应该是一致的。

如果要改变master分支的位置，Git只需要更改`refs/heads/master`的文件内容。同样地，创建新的分支也只需要将当前提交的哈希字串写入到新的文件中。这也是为什么Git分支比SVN轻量那么多的其中一个原因。

`tags`目录也是以相同的方式存储，只不过其中存的是标签而不是分支。`remotes`目录将你之前用`git remote`命令创建的所有远程仓库以子目录的形式一一列出。在每个文件夹中，你可以找到所有fetch到本地仓库的远程分支。

### 指定引用

当你向Git命令传入引用的时候，你既可以指定引用完整的名称，也可以使用缩写，然后让Git来寻找匹配。你应该已经对引用的缩写很熟悉了，每次你通过名称引用分支的时候都会这么做。

``` 
git show some-feature
```

这里的`some-feature`参数其实是分支名的缩写。Git在使用前将它解析成`refs/heads/some-feature`。你也可以在命令行中指定引用的全称，就像这样：

``` 
git show refs/heads/some-feature
```

这避免了引用可能产生的所有歧义。这是非常必要的，比如你同时有一个标签和分支都叫`some-feature`。然而，如果使用正常的命名规范，你不应该有这样的歧义。

我们会在refspec一节见到更多引用名称。

## 打包引用目录

对于大型仓库，Git会周期性地执行垃圾回收来移除不需要的对象，将所有引用文件压缩成单个文件来获得更好的性能。你可以使用这个命令强制垃圾回收来执行压缩：

``` 
git gc
```

这个命令把`refs`文件夹中所有单独的分支和标签移动到了`.git`根目录下的`packed-refs`文件中。如果你打开这个文件，你会发现提交的哈希字串和引用之间的映射关系：

``` 
00f54250cf4e549fdfcafe2cf9a2c90bc3800285 refs/heads/feature
0e25143693cfe9d5c2e83944bbaf6d3c4505eb17 refs/heads/master
bb883e4c91c870b5fed88fd36696e752fb6cf8e6 refs/tags/v0.9
```

另一方面，正常的Git功能不会受到任何影响。但如果你好奇你的`.git/refs`文件夹为什么是空的，这一节告诉你了答案。

## 特殊的引用

除了`refs`文件夹外，`.git`根目录还有一些特殊的引用。如下所示：

- HEAD – 当前所在的提交或分支。
- FETCH_HEAD – 远程仓库中fetch到的最新一次提交。
- ORIG_HEAD – HEAD的备份引用，避免损坏。
- MERGE_HEAD – 你通过`git merge`并入当前分支的引用(们)。
- CHERRY_PICK_HEAD – 你`cherry pick`使用的引用。

这些引用由Git在需要时创建和更新。比如说，`git pull`命令首先运行`git fetch`，而`FETCH_HEAD`引用随之改变。然后，运行`git merge FETCH_HEAD`来将fetch到的分支最终并入仓库。当然，你也可以使用其他任何引用，因为我相信你已经对`HEAD`很熟悉了。

这些文件包含的内容取决于它们的类型和你的仓库状态。`HEAD` 引用可以包含符号链接（指向另一个引用而不是哈希字串），或是提交的哈希字串。比如说，看看当你在master分支上时`HEAD`的内容：

``` 
git checkout master
cat .git/HEAD
```

这个命令会输出`ref: refs/heads/master`，也就是说HEAD指向`refs/heads/master`这个引用。这也正是Git如何知道现在所在的是master分支。如果你要切换分支，`HEAD`的内容将会被更新到新的分支。但如果你要切换到一个提交而不是分支，`HEAD`会包含一个提交的哈希而不是符号引用。这就是Git如何知道现在`HEAD`处于分离状态。

在大多数情况下，`HEAD`是你唯一用得到的引用。其它引用一般只在写底层脚本，接触到Git内部的工作机制时才会用到。



## refspec

refspec将本地分支和远程分支对应起来。我们可以通过它用本地的Git命令管理远程分支，设置一些高级的`git push`和`git fetch`行为。

refspec的定义是这样的：`[+]<src>:<dst>`。`<src>`参数是本地的源分支，`<dst>`是远程的目标分支。可选的`+`号强制远程仓库采用非快速向前的更新策略。

refspec可以和`git push`一起使用，用来指定远程的分支的名称。比如，下面这个命令将master分支推送到远程origin，就像一般的`git push`一样，但它使用qa-master作为远程仓库中的分支名。对于QA团队来说，这个方法非常有用。

``` 
git push origin master:refs/heads/qa-master
```

你也可以用refspec来删除远程分支。feature分支的工作流经常会遇到这种情况，将feature分支推送到远程仓库中（比如说为了备份）。你删除本地的feature分支之后，远程的feature分支依然存在，虽然现在我们已经不再需要它。你可以push一个`<src>`参数为空的refspec来删除它们，就像这样：

``` 
git push origin:some-feature
```

这非常方便，因为你不需要登录到你的远程仓库然后手动删除这些远程分支。注意，在Git v1.7.0之后你可以用`--delete`标记代替上面这个方法。下面这个命令和上面的命令作用相同：

``` 
git push origin --delete some-feature
```

在Git配置文件中增加几行，你就可以更改`git fetch`的行为。默认地，`git fetch`会fetch远程仓库中所有分支。原因就是`.git/config`文件的这段配置：

``` 
[remote "origin"]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/*:refs/remotes/origin/*
```

fetch这一行告诉`git fetch`从origin仓库中下载所有分支。但是，一些工作流不需要所有分支。比如，很多持续集成工作流只关心master分支。为了做到这一点，我们需要将fetch这行改成下面这样：

``` 
[remote "origin"]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/master:refs/remotes/origin/master
```

你还可以类似地修改`git push`的配置。比如，如果你总是将master分支推送到origin仓库的qa-master分支（就像我们之前做的一样），你要把配置文件改成这样：

``` 
[remote "origin"]
    url = https://git@github.com:mary/example-repo.git
    fetch = +refs/heads/master:refs/remotes/origin/master
    push = refs/heads/master:refs/heads/qa-master
```

refspec给了你完全的掌控权，可以定制Git命令如何在仓库之间转移分支。你可以重命名或是删除你的本地分支，fetch或是push不同的分支名，修改`git push`和`git fetch`的设置，只对你想要的分支进行操作。

## 相对引用

你还可以通过提交之间的相对关系来引用。`~`符号让你访问父节点的提交。比如说，下面这个命令显示`HEAD`祖父节点的提交：

``` 
git show HEAD~2
```

但是，面对合并提交(merge commit)的时候，事情就会变得有些复杂。因为合并提交有多个父节点，所以你可以找到多条回溯的路径。对于3路合并，第一个父节点是你执行合并时的分支，第二个父节点是你传给`git merge`命令的分支。

`~`符号总是选择合并提交的第一个父节点。如果你想选择其他父节点，你需要用`^`符号来指定。比如说，`HEAD`是一个合并提交，下面这个命令返回`HEAD`的第二个父节点：

``` 
git show HEAD^2
```

你可以使用不止一个`^`来查看超过一层的节点。比如，下面的命令显示的是`HEAD`的祖父节点，也就是`HEAD`第二个父节点的父节点。

``` 
git show HEAD^2^1
```

为了阐明`~`和`^`是如何工作的，下面这张图告诉你如何使用相对引用，来指向任意的提交。有的提交可以通过多种方式引用。

![Accessing commits using relative refs](https://www.atlassian.com/git/images/tutorials/advanced/refs-and-the-reflog/02.svg)

相对引用在命令中的用法和普通的引用相同。比如，下面所有命令中使用的都是相对引用：

``` 
# 只列出合并提交的第二个父节点的父节点
git log HEAD^2

# 移除当前分支最新的3个提交
git reset HEAD~3

# 交互式rebase当前分支最新的3个提交
git rebase -i HEAD~3
```

## 引用日志

引用日志是Git的安全网。它记录了你在仓库中做的所有更改，不管你有没有提交。你也可以认为这是你本地更改的完整历史记录。运行`git reflog`命令查看引用日志。它应该会打印出像下面这样的信息：

``` 
400e4b7 HEAD@{0}: checkout: moving from master to HEAD~2
0e25143 HEAD@{1}: commit (amend): 将一些很赞的新特性引入`master`
00f5425 HEAD@{2}: commit (merge): 合并'feature'分支
ad8621a HEAD@{3}: commit: 结束feature分支开发
```

说人话就是：

- 你刚刚切换到`HEAD~2`
- 你刚刚修改了一个提交信息
- 你刚刚把feature分支合并到了master分支
- 你刚刚提交了一份缓存

`HEAD{<n>}`语法允许你引用保存在日志中的提交。这和上一节的`HEAD~<n>`引用差不多，不过`<n>`指的是引用日志中的对象，而不是提交历史。

你可以用办法回到之前可能已经丢失的状态。比如，你刚刚用`git reset`方法粉碎了新的feature分支。你的引用日志看上去可能会是这样的：

``` 
ad8621a HEAD@{0}: reset: moving to HEAD~3
298eb9f HEAD@{1}: commit: 一些提交信息
bbe9012 HEAD@{2}: commit: 继续开发
9cb79fa HEAD@{3}: commit: 开始新特性开发
```

`git reset`前的三个提交现在都成了悬挂的了，也就是说除了引用日志之外没有办法再引用到它们。现在，假设你意识到了你不应该丢掉你全部的工作。你只需要切换到`HEAD@{1}`这个提交就能回到你运行`git reset`之前仓库的状态。

``` 
git checkout HEAD@{1}
```

这会让你处于`HEAD`分离的状态。你可以从这里开始，创建新的分支，继续你的工作。

## 总结

你现在对Git提交的引用应该已经相当熟悉了。我们知道了分支和标签是如何存在于`.git`的子文件夹refs中，如何读取打包的引用文件，如何使用refspec来进行更高级的push和fetch操作，如何使用`~`和`^`符号来遍历分支结构。

我们还了解了引用日志，来引用到其他方式已经不存在的提交。这是一种很好的恢复误删提交的方法。

它的意义在于：在任何开发场景下，你都能找到你需要的特定提交。你很容易就可以把这些技巧用在你一有的Git知识中，因为很多常用的命令都接受引用作为参数，包括`git log`、`git show`、`git checkout`、`git reset`、`git revert`、`git rebase`等等。