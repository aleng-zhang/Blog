---
layout: post
title: Git教程(一)
date: 2017-7-12
tags: [教程, 总结, 备忘]
---

> BY 童仲毅([geeeeeeeeek@github](https://github.com/geeeeeeeeek/git-recipes/))
>
> 这是一篇在[原文(BY atlassian)](https://www.atlassian.com/git/tutorials/setting-up-a-repository)基础上演绎的译文。除非另行注明，页面上所有内容采用知识共享-署名([CC BY 2.5 AU](http://creativecommons.org/licenses/by/2.5/au/deed.zh))协议共享。

---

## git init

`git init` 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。大多数Git命令在未初始化的仓库中都是无法使用的，所以这就是你运行新项目的第一个命令了。

运行 `git init` 命令会在你项目的根目录下创建一个新的 `.git` 目录，其中包含了你项目必需的所有元数据。除了 `.git` 目录之外，已经存在的项目不会被改变（就像 SVN 一样，Git 不强制每个子目录中都有一个 `.git` 目录）。

### 用法

``` shell
git init
```

将当前的目录转换成一个 Git 仓库。它在当前的目录下增加了一个 `.git` 目录，于是就可以开始记录项目版本了。

``` shell
git init <directory>
```

在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 `directory`，只包含 `.git` 子目录的空目录。

``` shell
git init --bare <directory>
```

初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 `--bare` 标记创建（见下面的讨论）。一般来说，用 `—bare` 标记初始化的仓库以 `.git` 结尾。比如，一个叫`my-project`的仓库，它的空版本应该保存在 `my-project.git` 目录下。

### 讨论

和 SVN 相比，`git init` 命令是一个创建新的版本控制项目非常简单的途径。Git 不需要你创建仓库，导入文件，检查正在修改的拷贝。你只需要 `cd` 到你的项目目录下，运行 `git init`，你就有了一个功能强大的 Git 仓库。

但是，对大多数项目来说，`git init` 只需要在创建中央仓库时执行一次——开发者通常不会使用 `git init` 来创建他们的本地仓库。他们往往使用 `git clone` 来将已存在的仓库拷贝到他们的机器中去。

#### 裸仓库

`-—bare` 标记创建了一个没有工作目录的仓库，这样我们在仓库中更改文件并且提交了。中央仓库应该总是创建成裸仓库，因为向非裸仓库推送分支有可能会覆盖已有的代码变动。将`-—bare`看成是用来将仓库标记为储存设施，而不是一个开发环境。也就是说，对于所有的 Git 工作流，中央仓库是裸仓库，开发者的本地仓库是非裸仓库。

![](https://www.atlassian.com/git/images/tutorials/getting-started/setting-up-a-repository/01.svg)

### 栗子

因为 `git clone` 创建项目的本地拷贝更为方便，`git init` 最常见的使用情景就是用于创建中央仓库：

``` shell
ssh <user>@<host>

cd path/above/repo

git init --bare my-project.git
```

首先，你用SSH连入存放中央仓库的服务器。然后，来到任何你想存放项目的地方，最后，使用 `-—bare` 标记来创建一个中央存储仓库。开发者会将 `my-project.git` 克隆到本地的开发环境中。

---

## git clone

`git clone` 命令拷贝整个 Git 仓库。这个命令就像 `svn checkout` 一样，除了「工作副本」是一个完备的Git仓库——它包含自己的历史，管理自己的文件，以及环境和原仓库完全隔离。

为了方便起见，`clone` 自动创建了一个名为 `origin` 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。

### 用法

``` shell
git clone <repo>
```

将位于 `<repo>` 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。

``` shell
git clone <repo> <directory>
```

将位于 `<repo>` 的仓库克隆到本地机器上的 `<directory>` 目录。

### 讨论

如果项目在远程仓库已经设置完毕，`git clone` 是用户获取开发副本最常见的方式。和  `git init`相似，`clone` 通常也是一次性的操作——只要开发者获得了一份工作副本，所有版本控制操作和协作管理都是在本地仓库中完成的。

#### 仓库间协作

这一点很重要，你要理解 Git 中「工作副本」的概念和 SVN 仓库 check out 下来的「工作副本」是很不一样的。和 SVN 不同的是，Git 不会区分工作副本和中央仓库——它们都是功能完备的 Git 仓库。

这就使得 Git 的协作和 SVN 截然不同。SVN 依赖于中央仓库和工作副本之间的关系，而 Git 协作模型是基于仓库和仓库之间的交互的。相对于 SVN 的提交流程，你可以在 Git 仓库之间 `push` 或 `pull` 提交。

![](https://www.atlassian.com/git/images/tutorials/getting-started/setting-up-a-repository/03.svg)

![](https://www.atlassian.com/git/images/tutorials/getting-started/setting-up-a-repository/02.svg)

当然，你也完全可以给予某个特定的仓库一些特殊的含义。比如，指定某个 Git 仓库为中央仓库，你就可以用 Git 进行中央化的工作流。重点是，这是通过约定实现的，而不是写死在版本控制系统本身。

### 栗子

下面这个例子演示用 SSH 用户名 john 连接到 example.com，获取远程服务器上中央仓库的本地副本：

``` shell
git clone ssh://john@example.com/path/to/my-project.git

cd my-project

# 开始工作
```

第一行命令在本地机器的 `my-project` 目录下初始化了一个新的 Git 仓库，并且导入了中央仓库中的文件。接下来，你 `cd` 到项目目录，开始编辑文件、缓存提交、和其它仓库交互。同时注意 `.git` 拓展名克隆时会被去除。它表明了本地副本的非裸状态。

``` shell
git config
```

`git config` 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。

### 用法

``` shell
git config user.name <name>
```

定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 `--global` 标记设置当前用户的配置项。

``` sh
git config --global user.name <name>
```

定义当前用户所有提交使用的作者姓名。

``` sh
git config --global user.email <email>
```

定义当前用户所有提交使用的作者邮箱。

``` sh
git config --global alias.<alias-name> <git-command>
```

为Git命令创建一个快捷方式（别名）。

``` sh
git config --system core.editor <editor>
```

定义当前机器所有用户使用命令时用到的文本编辑器，如 `git commit`。`<editor>` 参数用编辑器的启动命令（如 vi）替代。

``` sh
git config --global --edit
```

用文本编辑器打开全局配置文件，手动编辑。

### 讨论

所有配置项都储存在纯文本文件中，所以 `git config` 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 `--global` 标记。

Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。

- <repo>/.git/config – 特定仓库的设置。


- ~/.gitconfig – 特定用户的设置。这也是 `--global` 标记的设置项存放的位置。


- $(prefix)/etc/gitconfig – 系统层面的设置。

当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些：

``` sh
[user]

name = John Smith

email = john@example.com

[alias]

st = status

co = checkout

br = branch

up = rebase

ci = commit

[core]

editor = vim
```

你可以用 `git config` 手动编辑这些值。

### 栗子

你在安装 Git 之后想要做的第一件事是告诉它你的名字和邮箱，个性化一些默认设置。一般初始的设置过程看上去是这样的：

``` sh
# 告诉Git你是谁

git config --global user.name "John Smith"

git config --global user.email john@example.com

# 选择你喜欢的文本编辑器

git config --global core.editor vim

# 添加一些快捷方式(别名)

git config --global alias.st status

git config --global alias.co checkout

git config --global alias.br branch

git config --global alias.up rebase

git config --global alias.ci commit
```

它会生成上一节中所说的 `~/.gitconfig` 文件。

---

## git add

`git add`命令将工作目录中的变化添加到缓存区。它告诉Git你想要在下一次提交时包含这个文件的更新。但是，`git add`不会怎么影响你的仓库——在你运行`git commit`前更改都不会被记录。

使用这些命令之时，你还需要`git status`来查看工作目录和缓存区的状态。

### 用法

``` 
git add <file>
```

将`<file>`中的更改加入下次提交的缓存。

``` 
git add <directory>
```

将`<directory>`下的更改加入下次提交的缓存。

``` 
git add -p
```

开始交互式的缓存，你可以选择文件的一部分加入到下次提交缓存。它会向你展示一堆更改，等待你输入一个命令。`y`将这块更改加入缓存，`n`忽略这块更改，`s`将它分割成更小的块，`e`手动编辑这块更改，以及`q`退出。

### 讨论

`git add`和`git commit`这两个命令组成了最基本的Git工作流。每一个Git用户都需要理解这两个命令，不管他们团队的协作模型是如何的。我有一千种方式可以将项目版本记录在仓库的历史中。

在一个只有编辑、缓存、提交这样基本流程的项目上开发。首先，你要在工作目录中编辑你的文件。当你准备备份项目的当前状态时，你通过`git add`来缓存更改。当你对缓存的快照满意之后，你通过`git commit`将它提交到你的项目历史中去。



![Git Tutorial: git add Snapshot](https://www.atlassian.com/git/images/tutorials/getting-started/saving-changes/01.svg)



`git add`命令不能和 `svn add`混在一起理解，后者将文件添加到仓库中。而`git add` 发生于更抽象的 *更改* 层面。也就是说，`git add`在每次你修改一个文件时都需要被调用，而`svn add`只需要每个文件调用一次。这听上去很多余，但这样的工作流使得一个项目更容易组织。

#### 缓存区

缓存区是Git更为独特的地方之一，如果你是从SVN（甚至是Mercurial）迁移而来，那你可得花点时间理解了。你可以简单地把它想成是工作目录和项目历史之间的缓冲区。

缓存允许你在实际提交到项目历史之前，将相关的更改组合成一份高度专注的快照，而不是将你上次提交以后产生的所有更改一并提交。也就是说你可以更改各种不相关的文件，然后回过去将它们按逻辑切分，将相关的更改添加到缓存，一份一份提交。在任何修改控制系统中，很重要的一点是提交必须是原子性的，以便于追踪bug，并用最小的代价回滚更改。

### 栗子

当你开始新项目的时候，`git add`和`svn import`类似。为了创建当前目录的初始提交，使用下面两个命令：

``` 
git add .
git commit
```

当你项目设置好之后，新的文件可以通过路径传递给`git add`来添加：

``` 
git add hello.py
git commit
```

上面的命令同样可以用于记录已有文件的更改。重复一次，Git不会区分缓存的更改来自新文件，还是仓库中已有的文件。

## git commit

`git commit`命令将缓存的快照提交到项目历史。提交的快照可以认为是项目『安全』的版本——Git永远不会改变它们，除非你这么要求。和`git add`一样，这是最重要的Git命令之一。

尽管和它和`svn commit`名字一样，但实际上它们毫无关联。快照被提交到本地仓库，不会和其他Git仓库有任何交互。

### 用法

``` 
git commit
```

提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。

``` 
git commit -m "<message>"
```

提交已经缓存的快照。但将`<message>`作为提交信息，而不是运行文本编辑器。

``` 
git commit -a
```

提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过`git add`添加过的文件）。

### 讨论

快照总是提交到 *本地* 仓库。这一点和SVN截然不同，后者的工作拷贝提交到中央仓库。而Git不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。

这一点改变了Git用户基本的开发模型。Git开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这对于SVN风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。

#### 记录快照，而不是记录差异

SVN和Git除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN追踪文件的 *变化* ，而Git的版本控制模型基于 *快照* 。比如说，一个SVN提交由仓库中原文件相比的差异(diff)组成。而Git在每次提交中记录文件的 *完整内容* 。



![Git Tutorial: Snapshots, Not Differences](https://www.atlassian.com/git/images/tutorials/getting-started/saving-changes/02.svg)



这让很多Git操作比SVN来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从Git 的内部数据库中得到。

Git的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。

### 栗子

下面这个栗子假设你编辑了`hello.py`文件的一些内容，并且准备好将它提交到项目历史。首先，你需要用`git add`缓存文件，然后提交缓存的快照。

``` 
git add hello.py
git commit
```

它会打开一个文件编辑器（可以通过`git config`设置) 询问提交信息，同时列出将被提交的文件。

``` 
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
#modified: hello.py
```

Git对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用50个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如：

``` 
Change the message displayed by hello.py

- Update the sayHello() function to output the user's name
- Change the sayGoodbye() function to a friendlier message
```

注意，很多开发者倾向于在提交信息中使用一般现在时态。这样看起来更像是对仓库进行的操作，让很多改写历史的操作更加符合直觉。

---

## git status

`git status`命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被Git追踪。status的输出 *不会* 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用`git log`命令。

### 用法

``` 
git status
```

列出已缓存、未缓存、未追踪的文件。

### 讨论

`git status`是一个相对简单的命令。 它告诉你`git add`和`git commit`的进展。status信息还包括了添加缓存和移除缓存的相关指令。样例输出显示了三类主要的`git status`输出：

``` 
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
#modified: hello.py
#
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
# (use "git checkout -- <file>..." to discard changes in working directory)
#
#modified: main.py
#
# Untracked files:
# (use "git add <file>..." to include in what will be committed)
#
#hello.pyc
```

#### 忽略文件

未追踪的文件通常有两类。它们要么是项目新增但还未提交的文件，要么是像`.pyc` `.obj`  `.exe`等编译后的二进制文件。显然前者应该出现在`git status`的输出中，而后者会让我们困惑究竟发生了什么。

因此，Git允许你完全忽略这些文件，只需要将路径放在一个特定的`.gitignore`文件中。所有想要忽略的文件应该分别写在单独一行，*字符用作通配符。比如，将下面这行加入项目根目录的`.gitignore`文件可以避免编译后的Python模块出现在`git status`中：

``` 
*.pyc
```

### 栗子

在提交更改前检查仓库状态是一个良好的实践，这样你就不会不小心提交什么奇怪的东西。这个例子显示了缓存和提交快照前后的仓库状态：

``` 
# Edit hello.py
git status
# hello.py is listed under "Changes not staged for commit"
git add hello.py
git status
# hello.py is listed under "Changes to be committed"
git commit
git status
# nothing to commit (working directory clean)
```

第一个status的输出显示文件还未缓存。`git add`操作会影响第二个`git status`，最后的status输出告诉你已经没有可以提交的东西了——工作目录和最近的提交一致。一些Git命令（比如`git merge`）需要工作目录整洁，以免意外覆盖更改。

---

## git log

`git log` 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。`git status` 允许你查看工作目录和缓存区，而`git log`只作用于提交的项目历史。



![Git Tutorial: git status vs. git log](https://www.atlassian.com/git/images/tutorials/getting-started/inspecting-a-repository/01.svg)

log输出可以有很多种自定义的方式，从简单地筛选提交，到用完全自定义的格式显示。其中一些最常用的`git log`配置如下所示。

### 用法

``` 
git log
```

使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用`空格键`来滚动，按`q`退出。

``` 
git log -n <limit>
```

用`<limit>`限制提交的数量。比如`git log -n 3`只会显示3个提交。

``` 
git log --oneline
```

将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。

``` 
git log --stat
```

除了`git log`信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。

``` 
git log -p
```

显示代表每个提交的一堆信息。显示每个提交全部的差异(diff)，这也是项目历史中最详细的视图。

``` 
git log --author="<pattern>"
```

搜索特定作者的提交。`<pattern>`可以是字符串或正则表达式。

``` 
git log --grep="<pattern>"
```

搜索提交信息匹配特定`<pattern>`的提交。`<pattern>`可以是字符串或正则表达式。

``` 
git log <since>..<until>
```

只显示发生在`<since>`和`<until>`之间的提交。两个参数可以是提交ID、分支名、`HEAD`或是任何一种引用。

``` 
git log <file>
```

只显示包含特定文件的提交。查找特定文件的历史这样做会很方便。

``` 
git log --graph --decorate --oneline
```

还有一些有用的选项。`--graph`标记会绘制一幅字符组成的图形，左边是提交，右边是提交信息。`--decorate`标记会加上提交所在的分支名称和标签。`--oneline`标记将提交信息显示在同一行，一目了然。

### 讨论

`git log`命令是Git查看项目历史的基本工具。当你要寻找项目特定的一个版本或者弄明白合并功能分支时引入了哪些变化，你就会用到这个命令。

``` 
commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7
Author: John Smith
```

大多数时候都很简单直接。但是，第一行需要解释下。`commit`后面40个字的字符串是提交内容的SHA-1校验总和(checksum)。它有两个作用。一是保证提交的正确性——如果它被损坏了，提交会生成一个不同的校验总和。第二，它是提交唯一的标识ID。

这个ID可以用于`git log ..`这样的命令中来引用具体的提交。比如，`git log 3157e..5ab91`会显示所有ID在 `3157e`和`5ab91`之间的提交。除了校验总和之外，分支名、HEAD关键字也是常用的引用提交的方法。`HEAD`总是指向当前的提交，无论是分支还是特定提交也好。

~字符用于表示提交的父节点的相对引用。比如，`3157e~1`指向`3157e`前一个提交,`HEAD~3`是当前提交的回溯3个节点的提交。

所有这些标识方法的背后都是为了让你对特定提交进行操作。`git log`命令一般是这些交互的起点，因为它让你找到你想要的提交。

### 栗子

*用法* 一节提供了`git log`很多的栗子，但请记住，你可以将很多选项用在同一个命令中：

``` 
git log --author="John Smith" -p hello.py
```

这个命令会显示`John Smith`作者对`hello.py`文件所做的所有更改的差异比较(diff)。

..句法是比较分支很有用的工具。下面的栗子显示了在`some-feature`分支而不在`master`分支的所有提交的概览。

``` 
git log --oneline master..some-feature
```

---

## git checkout

`git checkout`这个命令有三个不同的作用：检出文件、检出提交和检出分支。在这一章中，我们只关心前两种用法。

检出提交会使工作目录和这个提交完全匹配。你可以用它来查看项目之前的状态，而不改变当前的状态。检出文件使你能够查看某个特定文件的旧版本，而工作目录中剩下的文件不变。

### 用法

``` 
git checkout master
```

回到master分支。分支会在下一节中讲到，而现在，你只需要将它视为回到项目『当前』状态的一种方式。

``` 
git checkout <commit> <file>
```

查看文件之前的版本。它将工作目录中的`<file>`文件变成`<commit>`中那个文件的拷贝，并将它加入缓存区。

``` 
git checkout <commit>
```

更新工作目录中的所有文件，使得和某个特定提交中的文件一致。你可以将提交的哈希字串，或是标签作为`<commit>`参数。这会使你处在分离HEAD的状态。

### 讨论

版本控制系统背后的思想就是『安全』地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库。当你建立了项目历史之后，`git checkout`是一种便捷的方式，来将保存的快照『加载』到你的开发机器上去。

检出之前的提交是一个只读操作。在查看旧版本的时候绝不会损坏你的仓库。你项目『当前』的状态在	`master`上不会变化。在开发的正常阶段，`HEAD`一般指向master或是其他的本地分支，但当你检出之前提交的时候，`HEAD`就不再指向一个分支了——它直接指向一个提交。这被称为『分离`HEAD`』状态 ，可以用下图可视化：



![Git Tutorial: Checking out a previous commit](https://www.atlassian.com/git/images/tutorials/getting-started/viewing-old-commits/01.svg)



在另一方面，检出旧文件不影响你仓库的当前状态。你可以在新的快照中像其他文件一样重新提交旧版本。所以，在效果上，`git checkout`的这个用法可以用来将单个文件回滚到旧版本 。



![Git Training: Checking out a previous version of a file](https://www.atlassian.com/git/images/tutorials/getting-started/viewing-old-commits/02.svg)



### 栗子

#### 查看之前的版本

这个栗子假定你开始了一个疯狂的实验，但你不确定你是否想要保留它。为了帮助你决定，你想看一看你开始实验之前的项目状态。首先，你需要找到你想要看的那个版本的ID。

``` 
git log --oneline
```

假设你的项目历史看上去和下面一样：

``` 
b7119f2 继续做些丧心病狂的事
872fa7e 做些丧心病狂的事
a1e8fb5 对hello.py做了一些修改
435b61d 创建hello.py
9773e52 初始导入
```

你可以这样使用`git checkout`来查看『对hello.py做了一些修改』这个提交：

``` 
git checkout a1e8fb5
```

这让你的工作目录和`a1e8fb5`提交所处的状态完全一致。你可以查看文件，编译项目，运行测试，甚至编辑文件而不需要考虑是否会影响项目的当前状态。你所做的一切 *都不会* 被保存到仓库中。为了继续开发，你需要回到你项目的『当前』状态：

``` 
git checkout master
```

这里假定了你默认在master分支上开发，我们会在以后的分支模型中详细讨论。

一旦你回到master分支之后，你可以使用 `git revert`或`git reset`来回滚任何不想要的更改。

#### 检出文件

如果你只对某个文件感兴趣，你也可以用`git checkout`来获取它的一个旧版本。比如说，如果你只想从之前的提交中查看`hello.py`文件，你可以使用下面的命令：

``` 
git checkout a1e8fb5 hello.py
```

记住，和检出提交不同，这里 *确实* 会影响你项目的当前状态。旧的文件版本会显示为『需要提交的更改』，允许你回滚到文件之前的版本。如果你不想保留旧的版本，你可以用下面的命令检出到最近的版本：

``` 
git checkout HEAD hello.py
```

这章教程提供了和项目旧版本打交道所需要的所有技巧。首先，你会知道如何浏览旧的提交，然后了解回滚项目历史中的公有提交和回滚本地机器上的私有更改之间的区别。

---

## git revert

`git revert`命令用来撤销一个已经提交的快照。但是，它是通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 *新* 提交，而不是从项目历史中移除这个提交。这避免了Git丢失项目历史，这一点对于你的版本历史和协作的可靠性来说是很重要的。



![Git Tutorial: git revert](https://www.atlassian.com/git/images/tutorials/getting-started/undoing-changes/03.svg)



### 用法

``` 
git revert <commit>
```

生成一个撤消了`<commit>`引入的修改的新提交，然后应用到当前分支。

### 讨论

撤销(revert)应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用`git revert`，它帮你做了所有的事情。

#### 撤销(revert)和重设(reset)对比

理解这一点很重要——`git revert`回滚了『单独一个提交』——它没有移除后面的提交，然后回到项目之前的状态。在Git中，后者实际上被称为`reset`，而不是`revert`。



![Git Tutorial: Revert vs Reset](https://www.atlassian.com/git/images/tutorials/getting-started/undoing-changes/04.svg)

撤销和重设相比有两个重要的优点。首先，它不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。至于为什么改变共享的历史是危险的，请参阅`git reset`一节。

其次，`git revert`可以针对历史中任何一个提交，而`git reset`只能从当前提交向前回溯。比如，你想用`git reset`重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。不用说，这并不是一个优雅的回滚方案。

### 栗子

下面的这个栗子是`git revert`一个简单的演示。它提交了一个快照，然后立即撤销这个操作。

``` 
# 编辑一些跟踪的文件

# 提交一份快照
git commit -m "Make some changes that will be undone"

# 撤销刚刚的提交
git revert HEAD
```

这个操作可以用下图可视化：



![Git Tutorial: git revert Example](https://www.atlassian.com/git/images/tutorials/getting-started/undoing-changes/05.svg)



注意第四个提交在撤销后依然在项目历史中。`git revert`在后面增加了一个提交来撤销修改，而不是删除它。 因此，第三和第五个提交表示同样的代码，而第四个提交依然在历史中，以备以后我们想要回到这个提交。

---

## git reset

如果说`git revert`是一个撤销更改安全的方式，你可以将`git reset`看做一个 *危险* 的方式。当你用`git reset`来重设更改时(提交不再被任何引用或引用日志所引用)，我们无法获得原来的样子——这个撤销是永远的。使用这个工具的时候务必要小心，因为这是少数几个可能会造成工作丢失的命令之一。

和`git checkout`一样，`git reset`有很多种用法。它可以被用来移除提交快照，尽管它通常被用来撤销缓存区和工作目录的修改。不管是哪种情况，它应该只被用于 *本地* 修改——你永远不应该重设和其他开发者共享的快照。

### 用法

``` 
git reset <file>
```

从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。

``` 
git reset
```

重设缓冲区，匹配最近的一次提交，但工作目录不变。它会取消 *所有* 文件的缓存，而不会覆盖任何修改，给你了一个重设缓存快照的机会。

``` 
git reset --hard
```

重设缓冲区和工作目录，匹配最近的一次提交。除了取消缓存之外，`--hard` 标记告诉Git还要重写所有工作目录中的更改。换句话说：它清除了所有未提交的更改，所以在使用前确定你想扔掉你所有本地的开发。

``` 
git reset <commit>
```

将当前分支的末端移到`<commit>`，将缓存区重设到这个提交，但不改变工作目录。所有`<commit>`之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。

``` 
git reset --hard <commit>
```

将当前分支的末端移到`<commit>`，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了`<commit>`之后的所有提交。

### 讨论

上面所有的调用都是用来移除仓库中的修改。没有`--hard`标记时`git reset`通过取消缓存或取消一系列的提交，然后重新构建提交来清理仓库。而加上`--hard`标记对于作了大死之后想要重头再来尤其方便。

撤销(revert)被设计为撤销 *公开* 的提交的安全方式，`git reset`被设计为重设 *本地* 更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。



![Git Tutorial: Revert vs Reset](https://www.atlassian.com/git/images/tutorials/getting-started/undoing-changes/06.svg)



#### 不要重设公共历史

当有`<commit>`之后的提交被推送到公共仓库后，你绝不应该使用`git reset`。发布一个提交之后，你必须假设其他开发者会依赖于它。

移除一个其他团队成员在上面继续开发的提交在协作时会引发严重的问题。当他们试着和你的仓库同步时，他们会发现项目历史的一部分突然消失了。下面的序列展示了如果你尝试重设公共提交时会发生什么。`origin/master`是你本地`master`分支对应的中央仓库中的分支。



![Git Tutorial: Resetting an Public Commit](https://www.atlassian.com/git/images/tutorials/getting-started/undoing-changes/07.svg)



一旦你在重设之后又增加了新的提交，Git会认为你的本地历史已经和`origin/master`分叉了，同步你的仓库时的合并提交(merge commit)会使你的同事困惑。

重点是，确保你只对本地的修改使用`git reset`——而不是公共更改。如果你需要修复一个公共提交，`git revert`命令正是被设计来做这个的。

### 栗子

#### 取消文件缓存

`git reset`命令在准备缓存快照时经常被用到。下面的例子假设你有两个文件，`hello.py`和`main.py`它们已经被加入了仓库中。

``` 
# 编辑了hello.py和main.py

# 缓存了目录下所有文件
git add .

# 意识到hello.py和main.py中的修改
# 应该在不同的快照中提交

# 取消main.py缓存
git reset main.py

# 只提交hello.py
git commit -m "Make some changes to hello.py"

# 在另一份快照中提交main.py
git add main.py
git commit -m "Edit main.py"
```

如你所见，`git reset`帮助你取消和这次提交无关的修改，让提交能够专注于某一特定的范围。

#### 移除本地修改

下面的这个栗子显示了一个更高端的用法。它展示了你作了大死之后应该如何扔掉那几个更新。

``` 
# 创建一个叫`foo.py`的新文件，增加代码

# 提交到项目历史
git add foo.py
git commit -m "Start developing a crazy feature"

# 再次编辑`foo.py`，修改其他文件

# 提交另一份快照
git commit -a -m "Continue my crazy feature"

# 决定废弃这个功能，并删除相关的更改
git reset --hard HEAD~2
```

`git reset HEAD~2`命令将当前分支向前倒退两个提交，相当于在项目历史中移除刚创建的这两个提交。记住，这种重设只能用在 *非公开* 的提交中。绝不要在将提交推送到共享仓库之后执行上面的操作。

---

## git clean

`git clean`命令将未跟踪的文件从你的工作目录中移除。它只是提供了一条捷径，因为用`git status`查看哪些文件还未跟踪然后手动移除它们也很方便。和一般的`rm`命令一样，`git clean`是无法撤消的，所以在删除未跟踪的文件之前想清楚，你是否真的要这么做。

`git clean`命令经常和`git reset --hard`一起使用。记住，reset只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。

### 用法

``` 
git clean -n
```

执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。

``` 
git clean -f
```

移除当前目录下未被跟踪的文件。`-f`(强制)标记是必需的，除非`clean.requireForce`配置项被设为了`false` (默认为`true`)。它 *不会* 删除 `.gitignore`中指定的未跟踪的文件。

``` 
git clean -f <path>
```

移除未跟踪的文件，但限制在某个路径下。

``` 
git clean -df
```

移除未跟踪的文件，以及目录。

``` 
git clean -xf
```

移除当前目录下未跟踪的文件，以及Git一般忽略的文件。

### 讨论

如果你在本地仓库中作死之后想要毁尸灭迹，`git reset --hard`和`git clean -f`是你最好的选择。运行这两个命令使工作目录和最近的提交相匹配，让你在干净的状态下继续工作。

`git clean`命令对于build后清理工作目录十分有用。比如，它可以轻易地删除C编译器生成的`.o`和`.exe`二进制文件。这通常是打包发布前需要的一步。`-x`命令在这种情况下特别方便。

请牢记，和`git reset`一样， `git clean`是仅有的几个可以永久删除提交的命令之一，所以要小心使用。事实上，它太容易丢掉重要的修改了，以至于Git厂商 *强制* 你用`-f`标志来进行最基本的操作。这可以避免你用一个`git clean`就不小心删除了所有东西。

### 栗子

下面的栗子清除了工作目录中的所有更改，包括新建还没加入缓存的文件。它假设你已经提交了一些快照，准备开始一些新的实验。

``` 
# 编辑了一些文件
# 新增了一些文件
# 『糟糕』

# 将跟踪的文件回滚回去
git reset --hard

# 移除未跟踪的文件
git clean -df
```

在执行了reset/clean的流程之后，工作目录和缓存区和最近一次提交看上去一模一样，而`git status`会认为这是一个干净的工作目录。你可以重新来过了。

注意，不像`git reset`的第二个栗子，新的文件没有被加入到仓库中。因此，它们不会受到`git reset --hard`的影响，需要`git clean`来删除它们。

---

## git commit --amend

`git commit --amend`命令是修复最新提交的便捷方式。它允许你将缓存的修改和之前的提交合并到一起，而不是提交一个全新的快照。它还可以用来简单地编辑上一次提交的信息而不改变快照。

![Git Tutorial: git commit --amend](https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/01.svg)

但是，amend不只是修改了最新的提交——它进行了一次替换。对于Git来说，这看上去像一个全新的提交，即上图中用星号表示的那一个。在公共仓库工作时一定要牢记这一点。

### 用法

``` 
git commit --amend
```

合并缓存的修改和上一次的提交，用新的快照替换上一个提交。缓存区没有文件时运行这个命令可以用来编辑上次提交的提交信息，而不会更改快照。

### 讨论

仓促的提交在你日常开发过程中时常会发生。很容易就忘记了缓存一个文件或者弄错了提交信息的格式。`--amend`标记是修复这些小意外的便捷方式。

#### 不要修复公共提交

在[`git reset`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9#git-reset)这节中，我们说过永远不要重设和其他开发者共享的提交。对于修复也是一样：永远不要修复一个已经推送到公共仓库中的提交。

修复过的提交事实上是全新的提交，之前的提交会被移除出项目历史。这和重设公共快照的后果是一样的。如果你修复了其他开发者在之后继续开发的一个提交，看上去他们的工作基础从项目历史中消失了一样。对于在这上面的开发者来说这是很困惑的，而且很难恢复。

### 栗子

下面这个🌰展示了Git开发工作流中的一个常见情形。我们编辑了一些希望在同一个快照中提交的文件，但我们忘记添加了其中的一个。修复错误只需要缓存那个文件并且用`--amend`标记提交：

``` 
# 编辑 hello.py 和 main.py
git add hello.py
git commit

# 意识到你忘记添加 main.py 的更改
git add main.py
git commit --amend --no-edit
```

编辑器会弹出上一次提交的信息，加入`--no-edit`标记会修复提交但不修改提交信息。需要的话你可以修改，不然的话就像往常一样保存并关闭文件。完整的提交会替换之前不完整的提交，看上去就像我们在同一个快照中提交了`hello.py`和`main.py`。

---

## git rebase

变基(rebase, 事实上这个名字十分诡异, 所以在大多数时候直接用英文术语)是将分支移到一个新的基提交的过程。过程一般如下所示：



![Git Tutorial: Rebase to maintain a linear project history.](https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/02.svg)



从内容的角度来看，rebase只不过是将分支从一个提交移到了另一个。但从内部机制来看，Git是通过在选定的基上创建新提交来完成这件事的——它事实上重写了你的项目历史。理解这一点很重要，尽管分支看上去是一样的，但它包含了全新的提交。

### 用法

``` 
git rebase <base>
```

将当前分支rebase到`<base>`，这里可以是任何类型的提交引用（ID、分支名、标签，或是`HEAD`的相对引用）。

### 讨论

rebase的主要目的是为了保持一个线性的项目历史。比如说，当你在feature分支工作时master分支取得了一些进展：



![Git Rebase Branch onto Master](https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/03.svg)



要将你的feature分支整合进`master`分支，你有两个选择：直接merge，或者先rebase后merge。前者会产生一个三路合并(3-way merge)和一个合并提交，而后者产生的是一个快速向前的合并以及完美的线性历史。下图展示了为什么rebase到`master`分支会促成一个快速向前的合并。

![Git Tutorial: Fast-forward merge](https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/04.svg)

rebase是将上游更改合并进本地仓库的通常方法。你每次想查看上游进展时，用`git merge`拉取上游更新会导致一个多余的合并提交。在另一方面，rebase就好像是说：“我想将我的更改建立在其他人的进展之上。”

#### 不要rebase公共历史

和我们讨论过的`git commit --amend`和`git reset`一样，你永远不应该rebase那些已经推送到公共仓库的提交。rebase会用新的提交替换旧的提交，你的项目历史会像突然消失了一样。

### 栗子

下面这个🌰同时使用git rebase和git merge来保持线性的项目历史。这是一个确认你的合并都是快速向前的方法。

``` 
# 开始新的功能分支
git checkout -b new-feature master
# 编辑文件
git commit -a -m "Start developing a feature"
```

在feature分支开发了一半的时候，我们意识到项目中有一个安全漏洞:

``` 
# 基于master分支创建一个快速修复分支
git checkout -b hotfix master
# 编辑文件
git commit -a -m "Fix security hole"
# 合并回master
git checkout master
git merge hotfix
git branch -d hotfix
```

将hotfix分支并回之后master，我们有了一个分叉的项目历史。我们用rebase整合feature分支以获得线性的历史，而不是使用普通的git merge。

``` 
git checkout new-feature
git rebase master
```

它将new-feature分支移到了master分支的末端，现在我们可以在master上进行标准的快速向前合并了:

``` 
git checkout master
git merge new-feature
```

---

## git rebase -i

用`-i`标记运行`git rebase`开始交互式rebase。交互式rebase给你在过程中修改单个提交的机会，而不是盲目地将所有提交都移到新的基上。你可以移除、分割提交，更改提交的顺序。它就像是打了鸡血的`git commit --amendy`一样。

### 用法

``` 
git rebase -i <base>
```

将当前分支rebase到`base`，但使用可交互的形式。它会打开一个编辑器，你可以为每个将要rebase的提交输入命令（见后文）。这些命令决定了每个提交将会怎样被转移到新的基上去。你还可以对这些提交进行排序。

### 讨论

交互式rebase给你了控制项目历史的完全掌控。它给了开发人员很大的自由，因为他们可以提交一个“混乱”的历史而只需专注于写代码，然后回去恢复干净。

大多数开发者喜欢在并入主代码库之前用交互式rebase来完善他们的feature分支。他们可以将不重要的提交合在一起，删除不需要的，确保所有东西在提交到“正式”的项目历史前都是整齐的。对其他人来说，这个功能的开发看上去是由一系列精心安排的提交组成的。

### 例子

下面这个🌰是`非交互式rebae`一节中🌰的可交互升级版本。

``` 
# 开始新的功能分支
git checkout -b new-feature master
# 编辑文件
git commit -a -m "Start developing a feature"
# 编辑更多文件
git commit -a -m "Fix something from the previous commit"

# 直接在master上添加文件
git checkout master
# 编辑文件
git commit -a -m "Fix security hole"

# 开始交互式rebase
git checkout new-feature
git rebase -i master
```

最后的那个命令会打开一个编辑器，包含new-feature的两个提交，和一些指示：

``` 
pick 32618c4 Start developing a feature
pick 62eed47 Fix something from the previous commit
```

你可以更改每个提交前的pick命令来决定在rebase时提交移动的方式。在我们的例子中，我们只需要用squash命令把两个提交并在一起就可以了：

``` 
pick 32618c4 Start developing a feature
squash 62eed47 Fix something from the previous commit
```

保存并关闭编辑器以开始rebase。另一个编辑器会打开，询问你合并后的快照的提交信息。在定义了提交信息之后，rebase就完成了，你可以在`git log`输出中看到那个提交。整个过程可以用下图可视化：



![Git Tutorial: git rebase -i example](https://www.atlassian.com/git/images/tutorials/getting-started/rewriting-history/05.svg)

注意缩并的提交和原来的两个提交的ID都不一样，告诉我们这确实是个新的提交。

最后，你可以执行一个快速向前的合并，来将完善的feature分支整合进主代码库：

``` 
git checkout master
git merge new-feature
```

交互式rebase强大的能力可以从整合后的master分支看出——额外的`62eed47`提交找不到了。对其他人来说，你就像是一个天才，用完美数量的提交完成了`new-feature`。这就是交互式提交如何保持项目历史干净和合意。

---

## git reflog

Git用引用日志这种机制来记录分支顶端的更新。它允许你回到那些不被任何分支或标签引用的更改。在重写历史后，引用日志包含了分支旧状态的信息，有需要的话你可以回到这个状态。

### 用法

``` 
git reflog
```

显示本地仓库的引用日志。

``` 
git reflog --relative-date
```

用相对的日期显示引用日志。(如2周前）。

### 讨论

每次当前的HEAD更新时（如切换分支、拉取新更改、重写历史或只是添加新的提交），引用日志都会添加一个新条目。

### 栗子

为了理解`git reflog`，我们来看一个🌰。

``` 
0a2e358 HEAD@{0}: reset: moving to HEAD~2
0254ea7 HEAD@{1}: checkout: moving from 2.2 to master
c10f740 HEAD@{2}: checkout: moving from master to 2.2
```

上面的引用日志显示了master和2.2 branch之间的相互切换。还有对一个更老的提交的强制重设。最近的活动用`HEAD@{0}`标记在上方显示。

如果事实上你是不小心切换回去的，引用日志包含了你意外地丢掉两个提交之前master指向的提交0254ea7。

``` 
git reset --hard 0254ea7
```

使用[`git reset`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9#git-reset)，就有可能能将master变回之前的那个提交。它提供了一张安全网，以防历史发生意外更改。

务必记住，引用日志提供的安全网只对提交到本地仓库的更改有效，而且只有移动操作会被记录。

---

## git remote

`git remote`命令允许你创建、查看和删除和其它仓库之间的连接。远程连接更像是书签，而不是直接跳转到其他仓库的链接。它用方便记住的别名引用不那么方便记住的URL，而不是提供其他仓库的实时连接。

例如，下图显示了你的仓库和中央仓库以及另一个开发者仓库之间的远程连接。你可以向Git命令传递origin和john的别名来引用这些仓库，替代完整的URL。



![Git Tutorial: git remote](https://www.atlassian.com/git/images/tutorials/collaborating/syncing/01.svg)



### 用法

``` 
git remote
```

列出你和其他仓库之间的远程连接。

``` 
git remote -v
```

和上个命令相同，但同时显示每个连接的URL。

``` 
git remote add <name> <url>
```

创建一个新的远程仓库连接。在添加之后，你可以将<name>作为<url>便捷的别名在其他Git命令中使用。

``` 
git remote rm <name>
```

移除名为<name>的远程仓库的连接。

``` 
git remote rename <old-name> <new-name>
```

将远程连接从<old-name>重命名为<new-name>。

### 讨论

Git被设计为给每个开发者提供完全隔离的开发环境。也就是说信息并不是自动地在仓库之间传递。开发者需要手动将上游提交拉取到本地，或手动将本地提交推送到中央仓库中去。`git remote`命令正是将URL传递给这些“共享”命令的快捷方式。

#### 名为origin的远程连接

当你用`git clone`克隆仓库时，它自动创建了一个名为origin的远程连接，指向被克隆的仓库。当开发者创建中央仓库的本地副本时非常有用，因为它提供了拉取上游更改和发布本地提交的快捷方式。这也是为什么大多数基于Git的项目将它们的中央仓库取名为origin。

#### 仓库的URL

Git支持多种方式来引用一个远程仓库。其中两种最简单的方式便是HTTP和SSH协议。HTTP是允许匿名、只读访问仓库的简易方式。比如：

``` 
http://host/path/to/repo.git
```

但是，直接将提交推送到一个HTTP地址一般是不可行的（你不太可能希望匿名用户也能随意推送）。如果希望对仓库进行读写，你需要使用SSH协议：

``` 
ssh://user@host/path/to/repo.git
```

你需要在托管的服务器上有一个有效的SSH账户，但不用麻烦了，Git支持开箱即用的SSH认证连接。

### 栗子

除了origin之外，添加你同事的仓库连接通常会带来一些便利。比如，如果你的同事John在`dev.example.com/john.git`上维护了一个公开的仓库，你可以这样添加连接：

``` 
git remote add john http://dev.example.com/john.git
```

通过这种方式访问每个开发者的仓库，中央仓库之外的协作变得可能。这给维护大项目的小团队带来了极大的便利。

---

## git fetch

`git fetch`命令将提交从远程仓库导入到你的本地仓库。拉取下来的提交储存为远程分支，而不是我们一直使用的普通的本地分支。你因此可以在整合进你的项目副本之前查看更改。

### 用法

``` 
git fetch <remote>
```

拉取仓库中所有的分支。同时会从另一个仓库中下载所有需要的提交和文件。

``` 
git fetch <remote> <branch>
```

和上一个命令相同，但只拉取指定的分支。

### 讨论

当你希望查看其他人的工作进展时，你需要fetch。fetch下来的内容表示为一个远程分支，因此不会影响你的本地开发。这是一个安全的方式，在整合进你的本地仓库之前，检查那些提交。类似于svn update，你可以看到中央仓库的历史进展如何，但它不会强制你将这些进展合并入你的仓库。

#### 远程分支

远程分支和本地分支一样，只不过它们代表这些提交来自于其他人的仓库。你可以查看像查看本地分支一样查看远程分支，但你会处于分离HEAD状态（就像查看旧的提交时一样）。你可以把它们视作只读的分支。如果想要查看远程分支，只需要向`git branch`命令传入`-r`参数。远程分支拥有remote的前缀，所以你不会将它们和本地分支混起来。比如，下面的代码片段显示了从origin拉取之后，你可能想要查看的分支：

``` 
git branch -r
# origin/master
# origin/develop
# origin/some-feature
```

同样，你可以用寻常的`git checkout`和 `git log`命令来查看这些分支。如果你接受远程分支包含的更改，你可以使用`git merge`将它并入本地分支。所以，不像SVN，同步你的本地仓库和远程仓库事实上是一个分两步的操作：先fetch，然后merge。`git pull`命令是这个过程的快捷方式。

### 栗子

这个例子回顾了同步本地和远程仓库`master`分支的常见工作流：

``` 
git fetch origin
```

它会显示会被下载的分支：

``` 
a1e8fb5..45e66a4 master -> origin/master
a1e8fb5..9e8ab1c develop -> origin/develop
* [new branch] some-feature -> origin/some-feature
```

在下图中，远程分支中的提交显示为方块，而不是圆圈。正如你所见，`git fetch`让你看到了另一个仓库完整的分支结构。



![Git Tutorial: git fetch](https://www.atlassian.com/git/images/tutorials/collaborating/syncing/02.svg)



若想查看添加到上游master上的提交，你可以运行`git log`，用 `origin/master`过滤：

``` 
git log --oneline master..origin/master
```

用下面这些命令接受更改并并入你的本地`master`分支：

``` 
git checkout master
git log origin/master
```

我们可以使用`git merge origin/master`：

``` 
git merge origin/master
```

origin/master和master分支现在指向了同一个提交，你已经和上游的更新保持了同步。

---

## git pull

在基于Git的协作工作流中，将上游更改合并到你的本地仓库是一个常见的工作。我们已经知道应该使用`git fetch`，然后是`git merge`，但是`git pull`将这两个命令合二为一。

### 用法

``` 
git pull <remote>
```

拉取当前分支对应的远程副本中的更改，并立即并入本地副本。效果和`git fetch `后接`git merge origin/.`一致。

``` 
git pull --rebase <remote>
```

和上一个命令相同，但使用`git rebase`合并远程分支和本地分支，而不是使用`git merge`。

### 讨论

你可以将`git pull`当做Git中对应`svn update`的命令。这是同步你本地仓库和上游更改的简单方式。下图结束了pull过程中的每一步。



![Git Tutorial: git pull](https://www.atlassian.com/git/images/tutorials/collaborating/syncing/03.svg)



你认为你的仓库已经同步了，但`git fetch`发现origin中`master`的版本在上次检查后已经有了新进展。 接着`git merge`立即将`remote master`并入本地的分支。

#### 基于Rebase的Pull 

`--rebase`标记可以用来保证线性的项目历史，防止合并提交(merge commits)的产生。很多开发者倾向于使用rebase而不是merge，因为“我想要把我的更改放在其他人完成的工作之后”。这种情况下，使用带有`--rebase`标记的`git pull`甚至更像svn update，与普通的`git pull`相比而言。

事实上，使用`--rebase`的pull的工作流是如此普遍，以致于你可以直接在配置项中设置它：

``` 
git config --global branch.autosetuprebase always
```

在运行这个命令之后，所有的`git pull`命令将使用`git rebase,`而不是`git merge`。

### 栗子

下面的栗子演示了如何和一个中央仓库的`master branch`同步：

``` 
git checkout master
git pull --rebase origin
```

简单地将你本地的更改放到其他人已经提交的更改之后。

---

## git push

Push是你将本地仓库中的提交转移到远程仓库中时要做的事。它和`git fetch`正好相反，fetch将提交导入到本地分支，而push将提交导出到远程分支。它可以覆盖已有的更改，所以你需要小心使用。这些情况请见下面的讨论。

### 用法

``` 
git push <remote> <branch>
```

将指定的分支推送到<remote>上，包括所有需要的提交和提交对象。它会在目标仓库中创建一个本地分支。为了防止你覆盖已有的提交，如果会导致目标仓库非快速向前合并时，Git不允许你push。

``` 
git push <remote> --force
```

和上一个命令相同，但即使会导致非快速向前合并也强制推送。除非你确定你所做的事，否则不要使用`--force`标记。

``` 
git push <remote> --all
```

将所有本地分支推送到指定的远程仓库。

``` 
git push <remote> --tags
```

当你推送一个分支或是使用`--all`选项时，标签不会被自动推送上去。`--tags`将你所有的本地标签推送到远程仓库中去。

### 讨论

`git push`最常见的用法是将你的本地更改发布到中央仓库。在你积累了一些本地提交，准备和同事们共享时，你（可以）用交互式rebase来清理你的提交，然后推送到中央仓库去。



![Git Tutorial: git push](https://www.atlassian.com/git/images/tutorials/collaborating/syncing/04.svg)



上图显示了当你本地的master分支进展超过了中央仓库的`master`分支，当你运行`git push origin master`发布更改时发生的事情。注意，`git push`和在远程仓库内部运行`git merge master`事实上是一样的。

#### 强制推送

Git为了防止你覆盖中央仓库的历史，会拒绝你会导致非快速向前合并的推送请求。所以，如果远程历史和你本地历史已经分叉，你需要将远程分支pull下来，在本地合并后再尝试推送。这和SVN让你在提交更改集合之前要和中央仓库同步是类似的。

`--force`这个标记覆盖了这个行为，让远程仓库的分支符合你的本地分支，删除你上次pull之后可能的上游更改。只有当你意识到你刚刚共享的提交不正确，并用`git commit --amend`或者交互式rebase修复之后，你才需要用到强制推送。但是，你必须绝对确定在你使用`--force`标记前你的同事们都没有pull这些提交。

#### 只推送到裸仓库

此外，你只应该推送到那些用`--bare`标记初始化的仓库。因为推送会弄乱远程分支结构，很重要的一点是，永远不要推送到其他开发者的仓库。但因为裸仓库没有工作目录，不会发生打断别人的开发之类的事情。

### 栗子

下面的栗子描述了将本地提交推送到中央仓库的一些标准做法。首先，确保你本地的`master`和中央仓库的副本是一致的，提前fetch中央仓库的副本并在上面rebase。交互式rebase同样是共享之前清理提交的好机会。接下来，`git push`命令将你本地`master`分支上的所有提交发送给中央仓库.

``` 
git checkout master
git fetch origin master
git rebase -i origin/master
# Squash commits, fix up commit messages etc.
git push origin master
```

因为我们已经确信本地的`master`分支是最新的，它应该导致快速向前的合并，`git push`不应该抛出非快速向前之类的问题。

---

## Pull Request简介

Pull request是开发者使用Github进行协作的利器。这个功能为用户提供了友好的页面，让提议的更改在并入官方项目之前，可以得到充分的讨论。

![qq20160127-0](https://cloud.githubusercontent.com/assets/7262715/12608331/8ece897e-c516-11e5-91c0-f7a44434478f.png)

最简单地来说，pull request是一种机制，让开发者告诉项目成员一个功能已经完成。一旦feature分支开发完毕，开发者使用Github账号提交一个pull request。它告诉所有参与者，他们需要审查代码，并将代码并入`master`分支。

但是，pull request不只是一个通知，还是一个专注于某个提议功能的讨论版。 如果更改导致了任何问题，团队成员可以在pull request下发布反馈，甚至推送后续提交来修改这个pull request。所有的活动都在这个pull request里之间追踪。

![Git Workflows: Activity inside a pull request](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/02.svg)

和其他协作模型相比，这种共享提交的解决方案形成了更加线性的工作流。SVN和Git都能通过一个简单的脚本发送通知邮件；但是，如果要讨论更改，开发者不得不在邮件里回复。这会变得愈发杂乱无章，尤其是后续提交出现时。Pull request将所有这些功能放入了一个友好的网页，在每个Github仓库上方都能找到。

### 剖析一个Pull Request

当你提交一个pull request的时候，你做的事情是 *请求 (request)* 另一个开发者（比如项目维护者）来 *拉取 (pull)* 你仓库中的一个分支到他们的仓库。也就是说你需要提供4个信息来完成一个pull request：源仓库、源分支、目标仓库、目标分支。

![Git Workflows: Pull Requests](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/03.svg)

Github会机智地帮你将一些值设为默认值。但是，取决于你的协作工作流，你的团队可能需要设置不同的值。上图显示了一个请求从feature分支合并到官方master分支的一个pull request，但除此之外还有好多种使用pull request的方式。

## Pull Request是如何工作的

Pull request可以和feature分支工作流、Gitflow工作流或者Fork工作流一起使用。但pull request需要两个不同的分支或是两个不同的仓库，因此它们不能和中心化的工作流一起使用。在不同的工作流中使用pull request有些不同，但大致的流程如下：

1. 开发者在他们的本地仓库中为某个功能创建一个专门的分支。
2. 开发者将分支推送到公共的Github仓库。
3. 开发者用Github发起一个pull request。
4. 其余的团队成员审查代码，讨论并且做出修改。
5. 项目维护者将这个功能并入官方的仓库，然后关闭这个pull request。

下面的章节讨论pull request在不同的协作工作流中有哪些不同。

### Feature分支工作流中的Pull Request

Feature分支工作流使用共享的Github仓库来管理协作，开发者在单独的feature分支中添加功能。开发者在将代码并入主代码库之前，应该发起一个pull request来启动这个功能的讨论，而不是直接将它们合并到`master`。

![Pull Request: Feature Branch workflow](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/04.svg)

在Feature分支工作流中只有一个公共的仓库，因此pull request的目标和源仓库永远是同一个。一般来说，开发者会将他们的feature分支作为源分支，`master`作为目标分支。

在收到pull request之后，项目维护者将会做出决定。如果这个功能可以立即发布，他们只需要将代码合并进`master`，然后关闭pull request即可。但是，如果提议的更改有一些问题，他们可以在pull request下发布反馈。后续提交将会显示在相关评论的下方。

你也可以发布一个未完成功能的pull request。例如，如果开发者在实现一个特殊的需求时遇到了问题，同样可以发布一个包含工作进展的pull request。其他开发者可以在这个pull request后面提供建议，甚至自己发布后续的提交来解决这个问题。

### Gitflow工作流中的Pull Request

Gitflow工作流和Feature分支工作流类似，但定义了围绕项目发布的一个严格的分支模型。在Gitflow工作流之上添加pull request使得开发者方便地讨论发布分支或是所在的维护分支。

![Pull Requests: Gitflow Workflow](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/05.svg)



![Pull Requests: Gitflow Workflow 2](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/06.svg)

在Gitflow工作流中的Pull request和上一节中的完全一致：开发者只需在功能、发布或是快速修复分支需要审查时发布一个pull request，Github会通知到其余的团队成员。

功能一般都会合并到`develop`分支，而发布和快速修复分支会被同时合并到`develop`和`master`当中。 Pull request可以用来妥善管理这些合并。

### Fork工作流中的Pull Request

在Fork工作流中，开发者将一个完成的功能推送到 *他们自己的* 仓库，而不是公共的仓库。在这之后，他们发布一个pull request，告诉项目维护者代码需要审查了。

在这个工作流中，pull request的通知作用显得非常有用，因为项目维护者无法获知其他开发者什么时候向他们自己的Github仓库中添加了提交。

![Pull Requests: Forking workflow](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/07.svg)

因为每个开发者都有他们自己的公共仓库，pull request的源仓库和目标仓库不是同一个。源仓库是开发者的公开仓库，源分支是包含提议更改的那一个。如果开发者想要将功能合并到主代码库，目标仓库便是官方的项目仓库，目标分支为`master`。

Pull request还可以用来和官方项目之外的开发者进行协作。比如说，一个开发者正在和同事一起开发一个功能，他们可以向 *同事的* Github仓库发起一个pull request，而不是官方仓库。他们将feature分支同时作为源分支和目标分支。

![Pull Requests: Forking workflow](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/08.svg)

两个开发者可以在pull request中讨论和开发分支。当功能完成时，其中一位可以发起另一个pull request，请求将功能合并到官方的master分支中去。这种灵活性使得pull request成为了Fork工作流中尤为强大的协作工具。

## 栗子

下面的🌰演示了如何将pull request用在Fork工作流中。小团队中的开发和向一个开源项目贡献代码都可以这样做。

在这个栗子中，Mary是一位开发者，John是项目的维护者。他们都有自己公开的Github仓库，John的仓库之一便是下面的官方项目。

### Mary fork了官方项目

![Pull Requests: Fork the project](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/09.svg)

为了参与这个项目，Mary首先要做的是fork John的Github仓库。她需要注册登录Github，找到John的仓库，点击Fork按钮。

> 下图显示的是geeeeeeeeek的WeChatLuckyMoney仓库。

![qq20160127-1](https://cloud.githubusercontent.com/assets/7262715/12614812/232fb7f2-c53d-11e5-80cb-68d2af29d6e9.png)

选好fork的目标位置之后，她在服务端就有了一个项目的副本。

### Mary克隆了她的Github仓库

![Pull Request: Clone the Bitbucket repo](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/11.svg)

接下来，Mary需要将她刚刚fork的Github仓库克隆下来。她在本地会有一份项目的副本。她需要运行下面这个命令：

``` 
git clone https://github.com/user/repo.git
```

请记住，`git clone`自动创建了一个名为`origin`的远端连接，指向Mary fork的仓库。

### Mary开发了一个新功能

![Pull Requests: develop a new feature](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/12.svg)

在她写任何代码之前，Mary需要为这个功能创建一个新的分支。这个分支将是她随后发起pull request时要用到的源分支。

``` 
git checkout -b some-feature
# 编辑一些代码
git commit -a -m "新功能的一些草稿"
```

为了完成这个新功能，Mary想创建多少个提交都可以。如果feature分支的历史有些乱，她可以使用交互式的rebase来移除或者拼接不必要的提交。对于大项目来说，清理feature的项目历史使得项目维护者更容易看清楚pull request的所处的进展。

### Mary将feature分支推送到了她的Github仓库

![Pull Requests: Push feature to Bitbucket repository](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/13.svg)

在功能完成后，Mary使用简单的`git push`将feature分支推送到了她自己的Github仓库上（不是官方的仓库）：

``` 
git push origin some-branch
```

这样她的更改就可以被项目维护者看到了（或者任何有权限的协作者）。

### Mary创建了一个pull request

![Pull Request: Create Pull Request](https://www.atlassian.com/git/images/tutorials/collaborating/making-a-pull-request/14.svg)

Github上已经有了她的feature分支之后，Mary可以找到被她fork的仓库，点击项目简介下的 *New Pull request* 按钮，用她的Github账号创建一个pull request。Mary的仓库会被默认设置为源仓库(head fork)，询问她指定源分支(compare)、目标仓库(base fork)和目标分支(base)。

Mary想要将她的功能并入主代码库，所以源分支就是她的feature分支，目标仓库就是John的公开仓库，目标分支为`master`。她还需要提供一个pull request的标题和简介。

> 下图展示的是将0492wzl/WeChatLuckyMoney(源仓库)的stable(源分支)合并到geeeeeeeeek/WeChatLuckyMoney(目标仓库)的stable(目标分支)。

![qq20160127-2](https://cloud.githubusercontent.com/assets/7262715/12615530/3088775a-c541-11e5-914e-d8232037e741.png)

在她创建了pull request之后，Github会给John发送一条通知。

### John审查了这个pull request

![qq20160127-3](https://cloud.githubusercontent.com/assets/7262715/12615618/b1373fd0-c541-11e5-9b91-47d40f8083ba.png)

John可以在他自己的Github仓库下的 *Pull Request* 选项卡中看到所有的pull request。点击Mary的pull request会显示这个pull request的简介、feature分支的提交历史，以及包含的更改。

如果他认为feature分支已经可以合并了，他只需点击*Merge Pull Request*按钮来通过这个pull request，将Mary的feature分支并入他的`master`分支。

但是，在这里栗子中，假设John发现了Mary代码中的一个小bug，需要她在合并前修复。他可以评论整个pull request，也可以评论feature分支中某个特定的提交。

![qq20160127-4](https://cloud.githubusercontent.com/assets/7262715/12615732/67c8c872-c542-11e5-9734-71751b83f63c.png)

### Mary添加了一个后续提交

如果Mary对这个反馈感到困惑，她可以在pull request后回复，把这里当做是她的功能的讨论版。

为了修复错误，Mary在她的feature分支后面添加了另一个提交，并将它推送到了她的Github仓库，就像她之前做的一样。这个提交被自动添加到原来的pull request后面，John可以在他的评论下方再次审查这些修改。

### John接受了pull request

最后，John接受了这些修改，将feature分支并入了master分支，关闭了这个pull request。功能现在已经整合到了项目中，其他在master分支上工作的开发者可以使用标准的`git pull`命令将这些修改拉取到自己的本地仓库。

> 如果你希望实践一下，可以按照上面的流程向这个项目发起一个pull request，修改任何你发现的错误:smile:

## 接下来怎么做？

你现在应该已经掌握了如何将你的pull request整合到你的工作流。记住，pull request不是替代任何Git工作流的万金油，而是一种让队员间协作锦上添花的工具。

---

## git branch

分支代表了一条独立的开发流水线。分支是我们在第二篇中讨论过的“编辑/缓存/提交”流程的抽象。你可以把它看作请求全新“工作目录、缓存区、项目历史”的一种方式。新的提交被存放在当前分支的历史中，导致了项目历史被fork了一份。

`git branch`命令允许你创建、列出、重命名和删除分支。它不允许你切换分支或是将被fork的历史放回去。因此，`git branch`和`git checkout`、`git merge`这两个命令通常紧密地结合在一起使用。

### 用法

``` 
git branch
```

列出仓库中所有分支。

``` 
git branch <branch>
```

创建一个名为`<branch>`的分支。*不会* 自动切换到那个分支去。

``` 
git branch -d <branch>
```

删除指定分支。这是一个“安全”的操作，Git会阻止你删除包含未合并更改的分支。

``` 
git branch -D <branch>
```

强制删除指定分支，即使包含未合并更改。如果你希望永远删除某条开发线的所有提交，你应该用这个命令。

``` 
git branch -m <branch>
```

将当前分支命名为`<branch>`。

### 讨论

在Git中，分支是你日常开发流程中的一部分。当你想要添加一个新的功能或是修复一个bug时——不管bug是大是小——你都应该新建一个分支来封装你的修改。这确保了不稳定的代码永远不会被提交到主代码库中，它同时给了你机会，在并入主分支前清理你feature分支的历史。



![Git Tutorial: git branch](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/01.svg)



比如，上图将一个拥有两条独立开发线的仓库可视化，其中一条是一个不起眼的功能，另一条是长期运行的功能。使用分支开发时，不仅可以同时在两条线上工作，还可以保持主要的`master branch`混入奇怪的代码。

#### 分支的顶端

Git分支背后的实现远比SVN的模型要轻量。与其在目录之间复制文件，Git将分支存为指向提交的引用。换句话说，分支代表了一系列提交的 *顶端* ——而不是提交的 *容器* 。分支历史通过提交之间的关系来推断。

这使得Git的合并模型变成了动态的。SVN中的合并是基于文件的，而Git让你在更抽象的提交层面操作。事实上，你可以看到项目历史中的合并其实是将两个独立的提交历史连接起来。

### 栗子

#### 创建分支

分支只是指向提交的 *指针* ，理解这一点很重要。当你创建一个分支是，Git只需要创建一个新的指针——仓库不会受到任何影响。因此，如果你最开始有这样一个仓库：



![Git Tutorial: repository without any branches](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/02.svg)



接下来你用下面的命令创建了一个分支：

``` 
git branch crazy-experiment
```

仓库历史保持不变。你得到的是一个指向当前提交的新的指针：



![Git Tutorial: Create new branch](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/03.svg)



注意，这只会 *创建* 一个新的分支。要开始在上面添加提交，你需要用`git checkout`来选中这个分支，然后使用标准的`git addh`和`git commit`命令。

#### 删除分支

一旦你完成了分支上的工作，准备将它并入主代码库，你可以自由地删除这个分支，而不丢失项目历史：

``` 
git branch -d crazy-experiment
```

然后，如果分支还没有合并，下面的命令会产生一个错误信息：

``` 
error: The branch 'crazy-experiment' is not fully merged.
If you are sure you want to delete it, run 'git branch -D crazy-experiment'.
```

Git保护你不会丢失这些提交的引用，或者说丢失访问整条开发线的入口。如果你 *真的* 想要删除这个分支（比如说这是一个失败的实验），你可以用大写的`-D`标记：

``` 
git branch -D crazy-experiment
```

它会删除这个分支，无视它的状态和警告，因此需谨慎使用。

---

## git checkout

`git checkout`命令允许你切换用`git branch`创建的分支。查看一个分支会更新工作目录中的文件，以符合分支中的版本，它还告诉Git记录那个分支上的新提交。将它看作一个选中你正在进行的开发的一种方式。

在上一篇中，我们看到了如何用`git checkout`来查看旧的提交。“查看分支”和“将工作目录更新到选中的版本/修改”很类似；但是，新的更改 *会* 保存在项目历史中——这不是一个只读的操作。

### 用法

``` 
git checkout <existing-branch>
```

查看特定分支，分支应该已经通过`git branch`创建。这使得<existing-branch>成为当前的分支，并更新工作目录的版本。

``` 
git checkout -b <new-branch>
```

创建并查看<new-branch>`-b`选项是一个方便的标记，告诉Git在运行`git checkout <new-branch>`之前运行`git branch <new-branch>`。

``` 
git checkout -b <new-branch> <existing-branch>
```

和上一条相同，但将<existing-branch>作为新分支的基，而不是当前分支。

### 讨论

`git checkouth`和`git branch`是一对好基友。当你想要创建一个新功能时，你用`git branch`创建分支，然后用`git checkout`查看。你可以在一个仓库中用`git checkout`切换分支，同时开发几个功能。



![Git Tutorial: Switch between multiple features in a single repo with git checkout.](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/04.svg)



每个功能专门一个分支对于传统SVN工作流来说是一个巨大的转变。这使得尝试新的实验超乎想象的简单，不用担心毁坏已有的功能，并且可以同时开发几个不相关的功能。另外，分支可以促进了不同的协作工作流。

#### 分离的`HEAD`

现在我们已经看到了`git checkout`最主要的三种用法，我们可以讨论上一篇中提到的“分离`HEAD`”状态了。

记住，`HEAD`是Git指向当前快照的引用。`git checkout`命令内部只是更新`HEAD`，指向特定分支或提交。当它指向分支时，Git不会报错，但当你check out提交时，它会进入“分离`HEAD`”状态。



![Git Tutorial: Attached vs Detached Head](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/05.svg)



有个警告会告诉你所做的更改和项目的其余历史处于“分离”的状态。如果你在分离`HEAD`状态开始开发新功能，没有分支可以让你回到之前的状态。当你不可避免地checkout到了另一个分支（比如你的更改并入了这个分支），你将不再能够引用你的feature分支：



![Git Tutorial: Detached Head state](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/06.svg)



重点是，你应该永远在分支上开发——而绝不在分离的`HEAD`上。这样确保你一直可以引用到你的新提交。不过，如果你只是想查看旧的提交，那么是否处于分离`HEAD`状态并不重要。

### 栗子

下面的栗子演示了基本的Git分支流程。当你想要开发新功能时，你创建一个专门的分支，切换过去：

``` 
git branch new-feature
git checkout new-feature
```

接下来，你可以和以往一样提交新的快照：

``` 
# 编辑文件
git add <file>
git commit -m "Started work on a new feature"
# 周而复始…
```

这些操作都被记录在`new-feature`上，和`master`完全独立。你想添加多少提交就可以添加多少，不用关心你其它分支的修改。当你想要回到“主”代码库时，只要check out到`master`分支即可：

``` 
git checkout master
```

这个命令在你开始新的分支之前，告诉你仓库的状态。在这里，你可以选择并入完成的新功能，或者在你项目稳定的版本上继续工作。

---

## git merge

合并是Git将被fork的历史放回到一起的方式。`git merge`命令允许你将`git branch`创建的多条分支合并成一个。

注意，下面所有命令将更改 *并入* 当前分支。当前分支会被更新，以响应合并操作，但目标分支完全不受影响。也就是说`git merge`经常和`git checkout`一起使用，选择当前分支，然后用`git branch -d`删除废弃的目标分支。

### 用法

``` 
git merge <branch>
```

将指定分支并入当前分支。Git会决定使用哪种合并算法（下文讨论）。

``` 
git merge --no-ff <branch>
```

将指定分支并入当前分支，但 *总是* 生成一个合并提交（即使是快速向前合并）。这可以用来记录仓库中发生的所有合并。

### 讨论

一旦你在单独的分支上完成了功能的开发，重要的是将它放回主代码库。取决于你的仓库结构，Git有几种不同的算法来完成合并：快速向前合并或者三路合并。

当当前分支顶端到目标分支路径是线性之时，我们可以采取 **快速向前合并** 。Git只需要将当前分支顶端（快速向前地）移动到目标分支顶端，即可整合两个分支的历史，而不需要“真正”合并分支。它在效果上合并了历史，因为目标分支上的提交现在在当前分支可以访问到。比如，`some-feature`到`master`分支的快速向前合并会是这样的：



![Git Tutorial: Fast-forward merge](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/07.svg)



但是，如果分支已经分叉了，那么就无法进行快速向前合并。当和目标分支之间的路径不是线性之时，Git只能执行 **三路合并** 。三路合并使用一个专门的提交来合并两个分支的历史。这个术语取自这样一个事实，Git使用 *三个* 提交来生成合并提交：两个分支顶端和它们共同的祖先。



![Git Tutorial: Three way merge](https://www.atlassian.com/git/images/tutorials/collaborating/using-branches/08.svg)



但你可以选择使用哪一种合并策略时，很多开发者喜欢使用快速向前合并（搭配rebase使用）来合并微小的功能或者修复bug，使用三路合并来整合长期运行的功能。后者导致的合并提交作为两个分支的连接标志。

#### 解决冲突

如果你尝试合并的两个分支同一个文件的同一个部分，Git将无法决定使用哪个版本。当这种情况发生时，它会停在合并提交，让你手动解决这些冲突。

Git的合并流程令人称赞的一点是，它使用我们熟悉的“编辑/缓存/提交”工作流来解决冲突。当你遇到合并冲突时，运行`git status`命令来查看哪些文件存在需要解决的冲突。比如，如果两个分支都修改了`hello.py`的同一处，你会看到下面的信息：

``` 
# On branch master
# Unmerged paths:
# (use "git add/rm ..." as appropriate to mark resolution)
#
# both modified: hello.py
#
```

接下来，你可以自己修复这个合并。当你准备结束合并时，你只需对冲突的文件运行`git add`告诉Git冲突已解决。然后，运行`git commit`生成一个合并提交。这和提交一个普通的快照有着完全相同的流程，也就是说，开发者能够轻而易举地管理他们的合并。

注意，提交冲突只会出现在三路合并中。在快速向前合并中，我们不可能出现冲突的更改。

### 栗子

#### 快速向前合并

我们第一个🌰演示了快速向前合并。下面的代码创建了一个分支，在后面添加了两个提交，然后使用快速向前合并将它并入主分支。

``` 
# 开始新功能
git checkout -b new-feature master

# 编辑文件
git add <file>
git commit -m "开始新功能"

# 编辑文件
git add <file>
git commit -m "完成功能"

# 合并new-feature分支
git checkout master
git merge new-feature
git branch -d new-feature
```

对于临时存在、用作独立开发环境而不是组织长期运行功能的工具的分支来说，这是一种常见的工作流。

同时注意，运行`git branch -d`时Git不应该产生错误提示，因为`new-feature`现在可以在主分支上访问了。

#### 三路合并

下一个栗子很相似，但需要进行三路合并，因为`master`在这个功能开发时取得了新进展。这是复杂功能和多个开发者同时工作时常见的情形。

``` 
# 开始新功能
git checkout -b new-feature master

# 编辑文件
git add <file>
git commit -m "开始新功能"

# 编辑文件
git add <file>
git commit -m "完成功能"

# 在master分支上开发
git checkout master

# 编辑文件
git add <file>
git commit -m "在master上添加了一些极其稳定的功能"

# 合并new-feature分支
git merge new-feature
git branch -d new-feature
```

注意，Git现在无法进行快速向前合并，因为无法将`master`直接移动到`new-feature`。

对大多数工作流来说，`new-feature`会是一个需要一段时间来开发的复杂功能，这也是为什么同时`master`会有新的提交出现。如果你的分支上的功能像上面的一样简单，你会更想将它rebase到`master`，使用快速向前合并。它会通过整理项目历史来避免多余的合并提交。

## 中心化的工作流



![Git Workflows: SVN-style Workflow](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/01.svg)



过渡到分布式分版本控制系统看起来是个令人恐惧的任务，但你不必为了利用Git的优点而改变你现有的工作流。你的团队仍然可以用以前SVN的方式开发项目。

然而，使用Git来驱动你的开发工作流显示出了一些SVN没有的优点。首先，它让每个开发者都有了自己 *本地* 的完整项目副本。隔离的环境使得每个开发者的工作独立于项目的其它修改——他们可以在自己的本地仓库中添加提交，完全无视上游的开发，直到需要的时候。

第二，它让你接触到了Git鲁棒的分支和合并模型。和SVN不同，Git分支被设计为一种故障安全的机制，用来在仓库之间整合代码和共享更改。

## 如何工作

和Subversion一样，中心化的工作流将中央仓库作为项目中所有修改的唯一入口。和`trunk`不同，默认的开发分支叫做`master`，所有更改都被提交到这个分支。这种工作流不需要`master`之外的其它分支。

开发者将中央仓库克隆到本地后开始工作。在他们的本地项目副本中，他们可以像SVN一样修改文件和提交更改；不过，这些新的提交被保存在 *本地* ——它们和中央仓库完全隔离。这使得开发者可以将和上游的同步推迟到他们方便的时候。

为了向官方项目发布修改，开发者将他们的本地`master`分支“推送”到中央仓库。这一步等同于`svn commit`，除了Git添加的是所有不在中央`master`分支上的本地提交。



![Central and local repositories](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/02.svg)



### 管理冲突

中央仓库代表官方项目，因此它的提交历史应该被视作神圣不可更改的。如果开发者的本地提交和中央仓库分叉了，Git会拒绝将他们的修改推送上去，因为这会覆盖官方提交。



![Managing Conflicts](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/03.svg)



在开发者发布他们的功能之前，他们需要fetch更新的中央提交，在它们之上rebase自己的更改。这就像是：“我想要在其他人的工作进展之上添加我的修改。”它会产生完美的线性历史，就像和传统的SVN工作流一样。

如果本地修改和上游提交冲突时，Git会暂停rebase流程，给你机会手动解决这些冲突。Git很赞的一点是，它将[`git status`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.4-%E6%A3%80%E6%9F%A5%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81#git-status)和[`git add`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.3-%E4%BF%9D%E5%AD%98%E4%BD%A0%E7%9A%84%E6%9B%B4%E6%94%B9#git-add)命令同时用来生成提交和解决合并冲突。这使得开发者能够轻而易举地管理他们的合并。另外，如果他们改错了什么，Git让他们轻易地退出rebase过程，然后重试（或者找人帮忙）。

## 栗子

让我们一步步观察一个普通的小团队是如何使用这种工作流协作的。我们有两位开发者，John和Mary，分别在开发两个功能，他们通过中心化的仓库共享代码。

### 一人初始化了中央仓库



![Git Workflows: Initialize Central Bare Repository](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/04.svg)



首先，需要有人在服务器上创建中央仓库。如果这是一个新项目，你可以初始化一个空的仓库。不然，你需要导入一个已经存在的Git或SVN项目。

中央仓库应该永远是裸仓库（没有工作目录），可以这样创建：

``` 
ssh user@host git init --bare /path/to/repo.git
```

但确保你使用的SSH用户名`user`、服务器`host`的域名或IP地址、储存仓库的地址`/path/to/repo.git`是有效的。注意`.git`约定俗成地出现在仓库名的后面，表明这是一个裸仓库。

### 所有人将仓库克隆到本地



![Git Workflows: Clone Central Repo](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/05.svg)





接下来，每个开发者在本地创建一份完整项目的副本。使用[`git clone`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.2-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93#git-clone)命令：

``` 
git clone ssh://user@host/path/to/repo.git
```

当你克隆仓库时，Git自动添加了一个名为`origin`的远程连接，指向“父”仓库，以便你以后和这个仓库交换数据。

### John在开发他的功能



![Git Workflows: Edit Stage Commit Feature Process ](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/06.svg)



在他的本地仓库中，John可以用标准的Git提交流程开发功能：编辑、缓存、提交。如果你对缓存区还不熟悉，你也可以不用记录工作目录中每次的变化。于是你创建了一个高度集中的提交，即使你已经在本地做了很多修改。

``` 
git status # 查看仓库状态
git add <some-file> # 缓存一个文件
git commit # 提交一个文件</some-file>
```

记住，这些命令创建的是本地提交，John可以周而复始地重复这个过程，而不用考虑中央仓库。对于庞大的功能，需要切成更简单、原子化的片段时，这个特性就很有用。

### Mary在开发她的功能



![Git Workflows: Edit Stage Commit Feature](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/07.svg)



同时，Mary在她自己的本地仓库用相同的编辑/缓存/提交流程开发她的功能。和John一样，她不需要关心中央仓库的进展，她也 *完全* 不关心John在他自己仓库中做的事，因为所有本地仓库都是私有的。

### John发布了他的功能



![Git Workflows: Publish Feature](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/08.svg)



一旦John完成了他的功能，他应该将本地提交发布到中央仓库，这样其他项目成员就可以访问了。他可以使用[`git push`](https://github.com/geeeeeeeeek/git-recipes/wiki/3.2-%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5#git-push)命令，就像：

``` 
git push origin master
```

记住，`origin`是John克隆中央仓库时指向它的远程连接。`master`参数告诉Git试着将`origin`的`master`分支变得和他本地的`master`分支一样。中央仓库在John克隆之后还没有进展，因此这个推送如他所愿，没有产生冲突。

### Mary试图发布她的功能



![Git Workflows: Push Command Error](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/09.svg)



John已经成功地将他的更改发布到了中央仓库上，看看当Mary试着将她的功能推送到上面时会发生什么。她可以使用同一个推送命令：

``` 
git push origin master
```

但是，她的本地历史和中央仓库已经分叉了，Git会拒绝这个请求，并显示一段冗长的错误信息：

``` 
error: failed to push some refs to '/path/to/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

Git防止Mary覆盖官方的修改。她需要将John的更新拉取到她的仓库，和她的本地修改整合后，然后重试。

### Mary在John的提交之上rebase



![Git Workflows: Git Pull Rebase](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/10.svg)



Mary可以使用[`git pull`](https://github.com/geeeeeeeeek/git-recipes/wiki/3.2-%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5#git-pull)来将上游修改并入她的仓库。这个命令和`svn update`很像——它拉取整个上游提交历史到Mary的本地仓库，并和她的本地提交一起整合：

``` 
git pull --rebase origin master
```

`--rebase`选项告诉Git，在同步了中央仓库的修改之后，将Mary所有的提交移到`master`分支的顶端，如下图所示：



![Rebasing to Master](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/11.svg)



如果你忽略这个选项拉取同样会成功，只不过你每次和中央仓库同步时都会多出一个“合并提交”。在这种工作流中，rebase和生成一个合并提交相比，总是一个更好的选择。

### Mary解决了合并冲突



![Git Workflows: Rebasing on Commits](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/12.svg)



Rebase的工作是将每个本地提交一个个转移到更新后的`master`分支。也就是说，你可以一个个提交分别解决合并冲突，而不是在一个庞大的合并提交中解决。它会让你的每个提交保持专注，并获得一个干净的项目历史。另一方面，你更容易发现bug是在哪引入的，如果有必要的话，用最小的代价回滚这些修改。

如果Mary和John开发的功能没有关联，rebase的过程不太可能出现冲突。但如果出现冲突时，Git在当前提交会暂停rebase，输出下面的信息，和一些相关的指令：

``` 
CONFLICT (content): Merge conflict in <some-file>
```



![Conflict Resolution](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/13.svg)



Git的优点在于 *每个人* 都能解决他们自己的合并冲突。在这个例子中，Mary只需运行一下[`git status`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.4-%E6%A3%80%E6%9F%A5%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81#git-status)就可以发现问题是什么。冲突的文件会出现在未合并路径中：

``` 
# Unmerged paths:
# (use "git reset HEAD <some-file>..." to unstage)
# (use "git add/rm <some-file>..." as appropriate to mark resolution)
#
# both modified: <some-file>
```

接下来，修改这些文件。如果她对结果满意了，和往常一样缓存这些文件，然后让[`git rebase`](https://github.com/geeeeeeeeek/git-recipes/wiki/2.7-%E9%87%8D%E5%86%99%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2#git-rebase)完成接下来的工作：

``` 
git add <some-file>
git rebase --continue
```

就是这样。Git会继续检查下个提交，对冲突的提交重复这个流程。

如果你这时候发现不知道自己做了什么，不要惊慌。只要运行下面的命令，你就会回到开始之前的状态：

``` 
git rebase --abort
```

### Mary成功发布了她的分支



![Git Workflows: Synchronize Central Repo](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/centralized-workflow/14.svg)



在她和中央仓库同步之后，Mary可以成功地发布她的修改：

``` 
git push origin master
```

## 接下来该怎么做

正如你所见，使用一丢丢Git命令来复制一套传统的Subversion开发环境也是可行的。这对于从SVN转变而来的团队来说很棒，但这样没有利用到Git分布式的本质。

如果你的团队已经习惯了中心化的工作流，但希望提高协作效率，那么探索[Feature分支工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#feature%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)的好处是完全值当的。每个功能在专门的独立分支上进行，在代码并入官方项目之前就可以启动围绕新修改的深度讨论。

## Feature分支的工作流



![Feature Branch Workflow](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/01.svg)



一旦你掌握了[中心化工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)的使用姿势，在你的开发流程中添加功能分支是一个简单的方式，来促进协作和开发者之间的交流。这种封装使得多个开发者专注自己的功能而不会打扰主代码库。它还保证`master`分支永远不会包含损坏的代码，给持续集成环境带来了是很大的好处。

封装功能的开发使得[pull request](https://github.com/geeeeeeeeek/git-recipes/wiki/3.3-%E5%88%9B%E5%BB%BAPull-Request)的使用成为可能，用来启动围绕一个分支的讨论。它给了其他开发者在功能并入主项目之前参与决策的机会。或者，如果你开发功能时卡在一半，你可以发起一个pull request，向同事寻求建议。重点是，pull request使得你的团队在评论其他人的工作时变得非常简单。

## 如何工作

Feature分支工作流同样使用中央仓库，`master`同样代表官方的项目历史。但是，与其直接提交在本地的`master`分支，开发者每次进行新的工作时创建一个新的分支。Feature分支应该包含描述性的名称，比如`animated-menu-items`(菜单项动画)或`issue-#1061`。每个分支都应该有一个清晰、高度集中的目的。

Git在技术上无法区别`master`和功能分支，所以开发者可以在feature分支上编辑、缓存、提交，就和中心化工作流中一样。

此外，feature分支可以（也应该）被推送到中央仓库。这使得你和其他开发者共享这个功能，而又不改变官方代码。既然`master`只是一个“特殊”的分支，在中央仓库中储存多个feature分支不会引出什么问题。当然了，这也是备份每个开发者本地提交的好办法。

### Pull Request

除了隔离功能开发之外，分支使得通过[pull request](https://github.com/geeeeeeeeek/git-recipes/wiki/3.3-%E5%88%9B%E5%BB%BAPull-Request)讨论修改成为可能。一旦有人完成了一个功能，他们不会立即将它并入`master`。他们将feature分支推送到中央服务器上，发布一个pull request，请求将他们的修改并入`master`。这给了其他开发者在修改并入主代码库之前审查的机会。

代码审查是pull request的主要好处，但他们事实上被设计为成为讨论代码的一般场所。你可以把pull request看作是专注某个分支的讨论版。也就是说他们可以用于开发流程之前。比如，一个开发者在某个功能上需要帮助，他只需发起一个pull request。感兴趣的小伙伴会自动收到通知，看到相关提交中的问题。

一旦pull request被接受了，发布功能的行为和中心化的工作流是一样的。首先，确定你本地的`master`和上游的`master`已经同步。然后，将feature分支并入`master`，将更新的`master`推送回中央仓库。

## 栗子

下面这个🌰演示了代码审查使用到的pull request，但记住pull request有多种用途。

### Mary开始了一个新功能



![New Feature Branch](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/02.svg)



在她开始开发一个功能之前，Mary需要一个独立的分支。她可以用下面的命令[创建新分支](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-checkout)：

``` 
git checkout -b marys-feature master
```

一个基于`master`、名为`marys-feature`的分支将会被checkout，`-b`标记告诉Git在分支不存在时创建它。在这个分支上，Mary和往常一样编辑、缓存、提交更改，用足够多的提交来构建这个功能：

``` 
git status
git add <some-file>
git commit
```

### Mary去吃饭了



![Git Workflows: Feature Commits](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/03.svg)



Mary在早上[给她的功能添加了一些提交](https://github.com/geeeeeeeeek/git-recipes/wiki/2.3-%E4%BF%9D%E5%AD%98%E4%BD%A0%E7%9A%84%E6%9B%B4%E6%94%B9#git-commit)。在她去吃午饭前，[将她的分支推送到中央仓库](https://github.com/geeeeeeeeek/git-recipes/wiki/3.2-%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5#git-push)是个不错的想法。这是一种方便的备份，但如果Mary和其他开发者一起协作，他们也可以看到她的初始提交了。

``` 
git push -u origin marys-feature
```

这个命令将`marys-feature`推送到中央仓库(`origin`)，`-u`标记将它添加为远程跟踪的分支。在设置完跟踪的分支之后，Mary调用不带任何参数的`git push`来推送她的功能。

### Mary完成了她的工作



![Git Workflows: Pull Request](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/04.svg)



当Mary吃完午饭回来，她完成了她的功能。在[并入`master`](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-merge)之前，她需要发布一个pull request，让其他的团队成员知道她所做的工作。但首先，她应该保证中央仓库包含了她最新的提交：

``` 
git push
```

然后，她在她的Git界面上发起了一个pull request，请求将`marys-feature`合并进`master`，团队成员会收到自动的通知。Pull request的好处是，评论显示在相关的提交正下方，方便讨论特定的修改。

### Bill收到了pull request



![Git Workflows: Feature Pull Requests](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/05.svg)



Bill收到了pull request，并且查看了`marys-feature`。他决定在并入官方项目之前做一些小修改，通过pull request和Mary进行了沟通。

### Mary作了修改



![Git Workflows: Central Repository Push](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/06.svg)



为了做这些更改，Mary重复了之前创建功能时相同的流程，她编辑、缓存、提交、将更新推送到中央仓库。她所有的活动显示在pull request中，Bill可以一直评论。

如果Bill想要的话，也可以将`marys-feature`pull到他自己的本地仓库，继续工作。后续的任何提交都会显示在pull request上。

### Mary发布了她的功能



![Merging a Feature Branch](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/feature-branch-workflow/07.svg)



一旦Bill准备接受这个pull request，某个人（Bill或者Mary都可）需要将功能并入稳定的项目：

``` 
git checkout master
git pull
git pull origin marys-feature
git push
```

首先，不管是谁在执行合并，都要保证他们的`master`分支是最新的。然后，运行`git pull origin marys-feature`合并中央仓库的`marys-feature`副本。你也可以使用简单的`git merge marys-feature`，但之前的命令保证你拉取下来的一定是功能分支最新的版本。最后，更新的`master`需要被推送回`origin`。

这个过程导致了一个合并提交。一些开发者喜欢它，因为它是功能和其余代码合并的标志。但，如果你希望得到线性的历史，你可以在执行merge之前将功能rebase到`master`分支的顶端，产生一个快速向前的合并。

一些界面会自动化接受pull request的流程，只需点击一下“Merge Pull Request”。如果你的没有的话，它至少在合并之后应该可以自动地关闭pull request。

### 同时，John以同样的方式工作着

Mary和Bill一起开发`marys-feature`，在pull request上讨论的同时，John还在开发他自己的feature分支。通过将功能用不同分支隔离开来，每个人可以独立地工作，但很容易和其他开发者共享修改。

## 接下来该怎么做

为了彻底了解Github上的功能分支，你应该查看[使用分支一章](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF)。现在，你应该已经看到了功能分支极大地增强了[中心化工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)中单一`master`分支的作用。除此之外，功能分支还便利了pull request的使用，在版本控制界面上直接讨论特定的提交。Gitflow工作流是管理功能开发、发布准备、维护的常见模式。

## Gitflow工作流



![Gitflow Workflow](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/01.svg)



下面的[Gitflow工作流](http://nvie.com/posts/a-successful-git-branching-model/)一节源于[nvie](http://nvie.com/)网站上的作者Vincent Driessen。

Gitflow工作流围绕项目发布定义了一个严格的分支模型。有些地方比[功能分支工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#feature%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)更复杂，为管理大型项目提供了鲁棒的框架。

和功能分支工作流相比，这种工作流没有增加任何新的概念或命令。它给不同的分支指定了特定的角色，定义它们应该如何、什么时候交流。除了功能分支之外，它还为准备发布、维护发布、记录发布分别使用了单独的分支。当然，你还能享受到功能分支工作流带来的所有好处：pull request、隔离实验和更高效的协作。

## 如何工作

Gitflow工作流仍然使用中央仓库作为开发者沟通的中心。和[其他工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83)一样，开发者在本地工作，将分支推送到中央仓库。唯一的区别在于项目的分支结构。

### 历史分支

和单独的`master`分支不同，这种工作流使用两个分支来记录项目历史。`master`分支储存官方发布历史，`develop`分支用来整合功能分支。同时，这还方便了在`master`分支上给所有提交打上版本号标签。



![Historical Branches](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/02.svg)



工作流剩下的部分围绕这两个分支的差别展开。

### 功能分支

每个新功能都放置在自己的分支中，可以[在备份/协作时推送到中央仓库](https://github.com/geeeeeeeeek/git-recipes/wiki/3.2-%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5#git-push)。但是，与其合并到`master`，功能分支将开发分支作为父分支。当一个功能完成时，它将被[合并回`develop`](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-merge)。功能永远不应该直接在`master`上交互。



![Feature Branches](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/03.svg)



注意，功能分支加上`develop`分支就是我们之前所说的功能分支工作流。但是，Gitflow工作流不止于此。

### 发布分支



![Release Branches](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/04.svg)



一旦`develop`分支的新功能足够发布（或者预先确定的发布日期即将到来），你可以从`develop`分支fork一个发布分支。这个分支的创建开始了下个发布周期，只有和发布相关的任务应该在这个分支进行，如修复bug、生成文档等。一旦准备好了发布，发布分支将合并进`master`，打上版本号的标签。另外，它也应该合并回`develop`，后者可能在发布启动之后有了新的进展。

使用一个专门的分支来准备发布确保一个团队完善当前的发布，其他团队可以继续开发下一个发布的功能。它还建立了清晰的开发阶段（比如说，“这周我们准备4.0版本的发布”，而我们在仓库的结构中也能看到这个阶段）。

通常我们约定：

- 从`develop`创建分支
- 合并进`master`分支
- 命名规范`release-* or release/*`

### 维护分支



![Maintenance Branches](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/05.svg)



维护或者“紧急修复”分支用来快速给产品的发布打上补丁。这是唯一可以从`master`上fork的分支。一旦修复完成了，它应该被并入`master`和`develop`分支（或者当前的发布分支），`master`应该打上更新的版本号的标签。

有一个专门的bug修复开发线使得你的团队能够处理issues，而不打断其他工作流或是要等到下一个发布周期。你可以将维护分支看作在`master`分支上工作的临时发布分支。

## 栗子

下面的栗子演示了这种工作流如何用来管理发布周期。假设你已经创建了中央仓库。

### 创建一个开发分支



![Create a Develop Branch](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/06.svg)



你要做的第一步是为默认的`master`分支创建一个互补的`develop`分支。最简单的办法是[在本地创建一个空的`develop`分支](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-branch)，将它推送到服务器上：

``` 
git branch develop
git push -u origin develop
```

这个分支将会包含项目中所有的历史，而`master`将包含不完全的版本。其他开发者应该[将中央仓库克隆到本地](https://github.com/geeeeeeeeek/git-recipes/wiki/2.2-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93#git-clone)，创建一个分支来追踪develop分支：

``` 
git clone ssh://user@host/path/to/repo.git
git checkout -b develop origin/develop
```

现在所有人都有了一份历史分支的本地副本。

### Mary和John开始了新功能



![New Feature Branches](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/07.svg)



我们的栗子从John和Mary在不同分支上工作开始。他们都要为自己的功能创建单独的分支。[他们的功能分支都应该基于`develop`](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-checkout)，而不是`master`：

``` 
git checkout -b some-feature develop
```

他们都使用“编辑、缓存、提交”的一般约定来向功能分支添加提交：

``` 
git status
git add <some-file>
git commit
```

### Mary完成了她的功能



![Merging a Feature Branch](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/08.svg)



在添加了一些提交之后，Mary确信她的功能以及准备好了。如果她的团队使用pull request，现在正是发起pull request的好时候，请求将她的功能并入`develop`分支。否则，她可以向下面一样，将它并入本地的`develop`分支，推送到中央仓库：

``` 
git pull origin develop
git checkout develop
git merge some-feature
git push
git branch -d some-feature
```

第一个命令在尝试并入功能分支之前确保`develop`分支已是最新。注意，功能绝不该被直接并入`master`。冲突的处理方式和[中心化工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)相同。

### Mary开始准备发布



![Preparing a Release](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/09.svg)



当John仍然在他的功能分支上工作时，Mary开始准备项目的第一个官方发布。和开发功能一样，她新建了一个分支来封装发布的准备工作。这也正是发布的版本号创建的一步：

``` 
git checkout -b release-0.1 develop
```

这个分支用来整理提交，充分测试，更新文档，为即将到来的发布做各种准备。它就像是一个专门用来完善发布的功能分支。

一旦Mary创建了这个分支，推送到中央仓库，这次发布的功能便被锁定了。不在`develop`分支中的功能将被推迟到下个发布周期。

### Mary完成了她的发布



![Merging Release into Master](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/10.svg)



一旦发布准备稳妥，Mary将它并入`master`和`develop`，然后删除发布分支。合并回`develop`很重要，因为可能已经有关键的更新添加到了发布分支上，而开发新功能需要用到它们。同样的，如果Mary的团队重视代码审查，现在将是发起pull request的完美时机。

``` 
git checkout master
git merge release-0.1
git push
git checkout develop
git merge release-0.1
git push
git branch -d release-0.1
```

发布分支是功能开发(`develop`)和公开发布(master)之间的过渡阶段。不论什么时候将提交并入`master`时，你应该为提交打上方便引用的标签：

``` 
git tag -a 0.1 -m "Initial public release" master
git push --tags
```

Git提供了许多钩子，即仓库中特定事件发生时被执行的脚本。当你向中央仓库推送`master`分支或者标签时，你可以配置一个钩子来自动化构建公开发布。

### 终端用户发现了一个bug



![Maintenance Branch](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/11.svg)



正式发布之后，Mary回过头来和John一起为下一个发布开发功能。这时，一个终端用户开了一个issue抱怨说当前发布中存在一个bug。为了解决这个bug，Mary（或John）从`master`创建了一个维护分支，用几个提交修复这个issue，然后直接合并回`master`。

``` 
git checkout -b issue-#001 master
# Fix the bug
git checkout master
git merge issue-#001
git push
```

和发布分支一样，维护分支包含了`develop`中需要的重要更新，因此Mary同样需要执行这个合并。接下来，她可以[删除这个分支](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-branch)了：

``` 
git checkout develop
git merge issue-#001
git push
git branch -d issue-#001
```

## 接下来该怎么做

现在，希望你已经很熟悉[中心化的工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)、[功能分支工作流](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#feature%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81)和Gitflow工作流。你应该已经可以抓住本地仓库、推送/拉取模式，和Git鲁棒的分支和合并模型的无限潜力。

请记住，教程中呈现的工作流只是可行的实践——而非工作中使用Git的金科玉律。因此，尽情地取其精华，去其糟粕吧。不变的是要让Git为你所用，而不是相反。

---

## Fork工作流

Fork工作流和教程中讨论的其它工作流截然不同。与其使用唯一的服务端仓库作为”中央“代码库，它给予 *每个* 开发者一个服务端仓库。也就是说每个贡献者都有两个Git仓库，而不是一个：一个私有的本地仓库和一个公开的服务端仓库。



![Git Workflows: Forking](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/01.svg)



Fork工作流的主要优点在于贡献可以轻易地整合进项目，而不需要每个人都推送到单一的中央仓库。开发者推送到他们 *自己的* 服务端仓库，只有项目管理者可以推送到官方仓库。这使得管理者可以接受任何开发者的提交，却不需要给他们中央仓库的权限。

结论是，这种分布式的工作流为大型、组织性强的团队（包括不可信的第三方）提供了安全的协作方式。它同时也是开源项目理想的工作流。

## 如何工作

和其它Git工作流一样，Fork工作流以一个储存在服务端的官方公开项目开场。但新的开发者想参与项目时，他们不直接克隆官方项目。

取而代之地，他们fork一份官方项目，在服务端创建一份副本。这份新建的副本作为他们私有的公开仓库——没有其他开发者可以在上面推送，但他们可以从上面拉取修改（在后面我们会讨论为什么这一点很重要）。在他们创建了服务端副本之后，开发者执行`git clone`操作，在他们的本地机器上复制一份。这是他们私有的开发环境，正如其他工作流中一样。

当他们准备好发布本地提交时，他们将提交推送到自己的公开仓库——而非官方仓库。然后，他们向主仓库发起一个pull request，让项目维护者知道一个更新做好了合并的准备。如果贡献的代码有什么问题的话，Pull request可以作为一个方便的讨论版。

我为了将功能并入官方代码库，维护者将贡献者的修改拉取到他们的本地仓库，确保修改不会破坏项目，将它[合并到本地的`master`分支](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-merge)，然后将`master`分支[推送](https://github.com/geeeeeeeeek/git-recipes/wiki/3.2-%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5#git-push)到服务端的官方仓库。贡献现在已是项目的一部分，其他开发者应该从官方仓库拉取并同步他们的本地仓库。

### 中央仓库

“官方”仓库这个概念在Fork工作流中只是一个约定，理解这一点很重要。从技术的角度，Git并看不出每个开发者和官方的公开仓库有什么区别。事实上，官方仓库唯一官方的原因是，它是项目维护者的仓库。

### Fork工作流中的分支

所有这些个人的公开仓库只是一个在开发者之间共享分支的约定。每个人仍然可以使用分支来隔离功能，就像在[功能分支工作流](](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#feature%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81))和[Gitflow工作流中](https://github.com/geeeeeeeeek/git-recipes/wiki/3.5-%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83#gitflow%E5%B7%A5%E4%BD%9C%E6%B5%81)一样。唯一的区别在于这些分支是如何开始的。在Fork工作流中，它们从另一个开发者的本地仓库拉取而来，而在功能分支和Gitflow分支它们被推送到官方仓库。

## 栗子

### 项目维护者初始化了中央仓库



![Forking Workflow: Shared Repository](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/02.svg)



和任何基于Git的项目一样，第一步是在服务端创建一个可以被所有项目成员访问到的官方仓库。一般来说，这个仓库同时还是项目维护者的公开仓库。

[公开的仓库应该永远是裸的](https://github.com/geeeeeeeeek/git-recipes/wiki/2.2-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93#git-init)，不管它们是否代表官方代码库。所以项目维护者应该运行下面这样的命令来设置官方仓库：

``` 
ssh user@host
git init --bare /path/to/repo.git
```

Github同时提供了一个图形化界面来替代上面的操作。这和教程中其它工作流设置中央仓库的流程完全一致。如果有必要的话，项目维护者应该将已有的代码库推送到这个仓库中。

### 开发者fork仓库



![Forking Workflow: Forking the official repository.](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/03.svg)



接下来，所有开发者需要fork官方仓库。你可以用SSH到服务器，运行`git clone`将它复制到服务器的另一个地址——fork其实只是服务端的clone。但同样地，Github上开发者只需点一点按钮就可以fork仓库。

在这步之后，每个开发者应该都有了自己的服务端仓库。像官方仓库一样，所有这些仓库都应该是裸仓库。

### 开发者将fork的仓库克隆到本地



![Forking Workflow: Cloning the forked repositories](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/04.svg)



接下来开发者需要克隆他们自己的公开仓库。他们可以用熟悉的`git clone`命令来完成这一步。

我们的栗子假设使用他们使用Github来托管仓库。记住，在这种情况下，每个开发者应该有他们自己的Github账号，应该用下面的命令克隆服务端仓库：

``` 
git clone https://user@github.com/user/repo.git
```

而教程中的其他工作流使用单一的`origin`远程连接，指向中央仓库，Fork工作流需要两个远程连接，一个是中央仓库，另一个是开发者个人的服务端仓库。你可以给这些远端取任何名字，约定的做法是将`origin`作为你fork后的仓库的远端（运行`git clone`是会自动创建）和`upstream`作为官方项目。

``` 
git remote add upstream https://github.com/maintainer/repo
```

你需要使用上面的命令来创建上游仓库的远程连接。它使得你轻易地保持本地仓库和官方仓库的进展同步。注意如果你的上游仓库开启了认证（比如它没有开源），你需要提供一个用户名，就像这样：

``` 
git remote add upstream https://user@bitbucket.org/maintainer/repo.git
```

它需要用户从官方代码库克隆或拉取之前提供有效的密码。

### 开发者进行自己的开发



![Forking Workflow: Developers work on features](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/05.svg)



在他们刚克隆的本地仓库中，开发者可以编辑代码、[提交更改](https://github.com/geeeeeeeeek/git-recipes/wiki/2.3-%E4%BF%9D%E5%AD%98%E4%BD%A0%E7%9A%84%E6%9B%B4%E6%94%B9#git-commit)，和其它分支中一样[创建分支](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-branch)：

``` 
git checkout -b some-feature
# 编辑代码
git commit -a -m "Add first draft of some feature"
```

他们所有的更改在推送到公开仓库之前都是完全私有的。而且，如果官方项目已经向前进展了，他们可以用`git pull`获取新的提交：

``` 
git pull upstream master
```

因为开发者应该在专门的功能分支开发，这一般会[产生一个快速向前的合并](https://github.com/geeeeeeeeek/git-recipes/wiki/3.4-%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF#git-merge)。

### 开发者发布他们的功能



![Forking Workflow: Developers publish features](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/06.svg)



一旦开发者准备好共享他们的新功能，他们需要做两件事情。第一，他们必须将贡献的代码推送到自己的公开仓库，让其他开发者能够访问到。他们的`origin`远端应该已经设置好了，所以他们只需要：

``` 
git push origin feature-branch
```

这和其他工作流不同之处在于，`origin`远端指向开发者个人的服务端仓库，而不是主代码库。

第二，他们需要通知项目维护者，他们想要将功能并入官方代码库。Github提供了一个“New Pull Request”按钮，跳转到一个网页，让你指明想要并入主仓库的分支。一般来说，你希望将功能分支并入上游远端的`master`分支。

### 项目维护者整合他们的功能



![Forking Workflow: Integrate Features](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/07.svg)



当项目维护者收到pull request时，他们的工作是决定是否将它并入官方的代码库。他们可以使用下面两种方式之一：

1. 直接检查pull request中检查代码
2. 将代码拉取到本地仓库然后手动合并

第一个选项更简单，让维护者查看修改前后的差异，在上面评论，然后通过图形界面执行合并。然而，如果pull request会导致合并冲突，第二个选项就有了必要。在这个情况中，维护者需要从开发者的服务端仓库fetch功能分支，合并到他们本地的`master`分支，然后解决冲突：

``` 
git fetch https://bitbucket.org/user/repo feature-branch
# 检查修改
git checkout master
git merge FETCH_HEAD
```

一旦修改被整合进本地的`master`，维护者需要将它推送到服务器上的官方仓库，这样其他开发者也可以访问它：

``` 
git push origin master
```

记住，维护者的`origin`指向他们的公开仓库，也就是项目的官方代码库。开发者的贡献现在完全并入了项目。

### 开发者和中央仓库保持同步



![Forking Workflow: Synchronize with the official repository](https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/forking-workflow/08.svg)



因为主代码库已经取得了新的进展，其他开发者应该和官方仓库同步：

``` 
git pull upstream master
```

## 接下来该怎么做

如果你从SVN迁移而来，Fork工作流看上去是一个比较大的转变。但不要害怕——它只是在Feature分支工作流之上引入了一层抽象。贡献的代码发布到开发者在服务端自己的仓库，而不是在唯一的中央仓库中直接共享分支。

这篇文章解释了一次代码贡献是如何从一个开发者流入官方的`master`分支的，但相同的方法可以用在将代码贡献整合进任何仓库。比如，如果你团队的一部分成员在一个特定功能上协作，他们可以用自己约定的行为共享修改——而不改变主仓库。

这使得Fork工作流对于松散的团队来说是个非常强大的工具。任何开发者都可以轻而易举地和其他开发者共享修改，任何分支都能高效地并入主代码库。